<!DOCTYPE html><html class="light"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="keywords" content="javascript tips, lập trình javascript, php tips, lập trình php, code javascript hay, lập trình php, fullstack, cộng đồng lập trình"/><title>Hướng dẫn sử dụng useCallback trong React</title><meta name="robots" content="index,follow"/><meta name="description" content="React hooks là một phương thức quản lý state mới trong function components, được giới thiệu trong phiên bản React v16.8"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="https://codestus.com/posts/huong-dan-su-dung-usecallback-trong-react"/><meta name="twitter:creator" content="@handle"/><meta property="og:title" content="Hướng dẫn sử dụng useCallback trong React"/><meta property="og:description" content="React hooks là một phương thức quản lý state mới trong function components, được giới thiệu trong phiên bản React v16.8"/><meta property="og:url" content="https://codestus.com/posts/huong-dan-su-dung-usecallback-trong-react"/><meta property="og:type" content="website"/><meta property="og:image" content="https://codestus.com/uploads/images/posts/3b9b3cd5-5376-4f5f-aa41-57dc9d46e045.png"/><meta property="og:image:alt" content="Hướng dẫn sử dụng useCallback trong React"/><meta property="og:image:secure_url" content="https://codestus.com/uploads/images/posts/3b9b3cd5-5376-4f5f-aa41-57dc9d46e045.png"/><meta property="og:image" content="/statics/open-graph-image.png"/><meta property="og:image:alt" content="Codestus.com"/><meta property="og:image:secure_url" content="/statics/open-graph-image.png"/><meta property="og:image:type" content="image/png"/><meta property="og:image:width" content="1500"/><meta property="og:image:height" content="780"/><meta property="og:site_name" content="codestus"/><link rel="canonical" href="https://codestus.com/posts/huong-dan-su-dung-usecallback-trong-react"/><link rel="manifest" href="/statics/icons/manifest.json"/><link rel="icon" href="/statics/icons/favicon.ico"/><link rel="apple-touch-icon" sizes="57x57" href="/statics/icons/apple-icon-57x57.png"/><link rel="apple-touch-icon" sizes="60x60" href="/statics/icons/apple-icon-60x60.png"/><link rel="apple-touch-icon" sizes="72x72" href="/statics/icons/apple-icon-72x72.png"/><link rel="apple-touch-icon" sizes="76x76" href="/statics/icons/apple-icon-76x76.png"/><link rel="apple-touch-icon" sizes="114x114" href="/statics/icons/apple-icon-114x114.png"/><link rel="apple-touch-icon" sizes="120x120" href="/statics/icons/apple-icon-120x120.png"/><link rel="apple-touch-icon" sizes="144x144" href="/statics/icons/apple-icon-144x144.png"/><link rel="apple-touch-icon" sizes="152x152" href="/statics/icons/apple-icon-152x152.png"/><link rel="apple-touch-icon" sizes="180x180" href="/statics/icons/apple-icon-180x180.png"/><link rel="icon" type="image/png" sizes="192x192" href="/statics/icons/android-icon-192x192.png"/><link rel="icon" type="image/png" sizes="32x32" href="/statics/icons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/statics/icons/favicon-96x96.png"/><link rel="icon" type="image/png" sizes="16x16" href="/statics/icons/favicon-16x16.png"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Blog","datePublished":"2021-02-14 00:09:29","description":"React hooks là một phương thức quản lý state mới trong function components, được giới thiệu trong phiên bản React v16.8","mainEntityOfPage":{"@type":"WebPage","@id":"https://codestus.com/posts/huong-dan-su-dung-usecallback-trong-react"},"headline":"Hướng dẫn sử dụng useCallback trong React","image":["https://codestus.com/uploads/images/posts/3b9b3cd5-5376-4f5f-aa41-57dc9d46e045.png"],"dateModified":"2022-03-31T08:30:02.000000Z","author":{"@type":"Person","name":"Trọng Dương Đức"}}</script><meta name="next-head-count" content="40"/><link rel="preload" href="/_next/static/css/ff8585426a3b9973.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ff8585426a3b9973.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-378e68e29c265886.js" defer=""></script><script src="/_next/static/chunks/framework-6e4ba497ae0c8a3f.js" defer=""></script><script src="/_next/static/chunks/main-54845d133638572e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-045bef3e0c3cc3fc.js" defer=""></script><script src="/_next/static/chunks/1bfc9850-9ce4addfb6ee5c45.js" defer=""></script><script src="/_next/static/chunks/52-79dcef6fd706c4e4.js" defer=""></script><script src="/_next/static/chunks/962-08ded6725e8aa3af.js" defer=""></script><script src="/_next/static/chunks/243-31bbdecca3072035.js" defer=""></script><script src="/_next/static/chunks/236-8c1cb74945fa7e8c.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-f9d48cd81d45a19a.js" defer=""></script><script src="/_next/static/8s9ir4i9lyTEt-H4jTUBS/_buildManifest.js" defer=""></script><script src="/_next/static/8s9ir4i9lyTEt-H4jTUBS/_ssgManifest.js" defer=""></script><script src="/_next/static/8s9ir4i9lyTEt-H4jTUBS/_middlewareManifest.js" defer=""></script></head><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""/><link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&amp;display=swap" rel="stylesheet"/><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
            j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
            'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
            })(window,document,'script','dataLayer','GTM-5GTSSXK');</script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-W5HXEXS0SF"></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-W5HXEXS0SF');</script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-148416370-3"></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-148416370-3');</script><script data-ad-client="ca-pub-3274325178159722" async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><body class="bg-grid-slate-100 scroll-smooth"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5GTSSXK" height="0" width="0"
            style="display:none;visibility:hidden"></iframe></noscript><div id="__next" data-reactroot=""><section><nav role="navigation"></nav><div class="container py-8 main-layout-css"><div data-testid="container-medium-test" style="max-width:968px" class="mx-auto px-4 lg:flex lg:flex-wrap my-32 items-start"><div class="utterances"></div><h1 class="text-4xl font-bold mb-16 w-full text-center">Hướng dẫn sử dụng useCallback trong React</h1><div class="w-full mb-6 lg:sticky top-8 space-x-4"><a class="inline-block"><div class="w-11 h-11 rounded-full bg-blue-50 hover:bg-blue-100 transition-all duration-300 inline-flex items-center justify-center cursor-pointer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="text-blue-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M257.5 445.1l-22.2 22.2c-9.4 9.4-24.6 9.4-33.9 0L7 273c-9.4-9.4-9.4-24.6 0-33.9L201.4 44.7c9.4-9.4 24.6-9.4 33.9 0l22.2 22.2c9.5 9.5 9.3 25-.4 34.3L136.6 216H424c13.3 0 24 10.7 24 24v32c0 13.3-10.7 24-24 24H136.6l120.5 114.8c9.8 9.3 10 24.8.4 34.3z"></path></svg></div></a><a class="inline-block" href="/"><div class="w-11 h-11 rounded-full bg-blue-50 hover:bg-blue-100 transition-all duration-300 inline-flex items-center justify-center cursor-pointer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 576 512" class="text-blue-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z"></path></svg></div></a></div><div class="md:w-4/12 md:pr-4 space-y-4 mb-10 md:mb-0 lg:sticky top-24"><nav><h2 class="text-md font-bold mb-2">Mục lục bài viết</h2><ul><li class="relative py-2 cursor-pointer border-l-2 border-l-gray-50/0 hover:border-l-blue-500 hover:bg-blue-50 text-sm font-semibold pl-2 pr-2"><span>Giới thiệu sơ về <code>useCallback</code></span><a class="absolute top-0 left-0 w-full h-full" href="#h2-gioi-thieu-so-ve-codeusecallbackcode"></a></li><li class="relative py-2 cursor-pointer border-l-2 border-l-gray-50/0 hover:border-l-blue-500 hover:bg-blue-50 text-sm font-semibold pl-2 pr-2"><span>Function Equality trong Javascript</span><a class="absolute top-0 left-0 w-full h-full" href="#h2-function-equality-trong-javascript"></a></li><li class="relative py-2 cursor-pointer border-l-2 border-l-gray-50/0 hover:border-l-blue-500 hover:bg-blue-50 text-sm font-semibold pl-2 pr-2"><span>Khi nào không nên sử dụng <code>useCallback</code></span><a class="absolute top-0 left-0 w-full h-full" href="#h2-khi-nao-khong-nen-su-dung-codeusecallbackcode"></a></li><li class="relative py-2 cursor-pointer border-l-2 border-l-gray-50/0 hover:border-l-blue-500 hover:bg-blue-50 text-sm font-semibold pl-2 pr-2"><span>Kết luận</span><a class="absolute top-0 left-0 w-full h-full" href="#h2-ket-luan"></a></li></ul></nav></div><div class="md:w-8/12 md:pl-4"><div class="prose"><p><strong>React hooks</strong> là một phương thức quản lý state mới trong function components, được giới thiệu trong phiên bản <strong>React v16.8</strong>. Với những hook như <strong>useState</strong>, <strong>useEffect</strong> và một số khác. Các nhà phát triển cuối cùng có thể làm việc với các <strong>side effects</strong> trong các thành phần chức năng.</p>
<p>Trong bài viết lần này, chúng ta sẽ xem xét về <strong>useCallback</strong>, một trong những <strong>hook</strong> được giới thiệu từ bản cập nhật của <strong>React</strong>, và tìm hiểu xem làm thế nào để chúng ta sử dụng <strong>useCallback</strong> tốt.</p>
<h2 id='h2-gioi-thieu-so-ve-codeusecallbackcode'>Giới thiệu sơ về <code>useCallback</code></h2>
<p><code>useCallback</code> là được sử dụng để tối ưu quá trình <strong>render</strong> của <strong>React functional components</strong>. Nó sẽ rất hữu ích đối với trường hợp một thành phần (component) liên tục được hiển thị lại không cần thiết trong quá trình xử lý sự kiện người dùng và có hành vi chức năng phức tạp. Chúng ta sẽ xem xét thông qua ví dụ đơn giản về cách triển khai hook này để xem cách nó có thể giúp chúng ta đạt hiệu quả thế nào trong quá trình xử lý <strong>re-rendering</strong> của <strong>component</strong>.</p>
<p>Hãy nhớ rằng <strong>React</strong> đã rất nhanh, tối ưu hiệu xuất chỉ nên sử dụng cho những component có khả năng chậm, xử lý tác vụ nặng. Khi đó, chúng ta sẽ xem xét xử dụng <code>useCallback</code> làm một phần hỗ trợ tối ưu hiện xuất trong các hook.</p>
<p>Nào, bây giờ hãy xem xét ví dụ đơn giản qua <code>Counter</code> Component nhé:</p>
<pre><code class="language-jsx">import React, { useState, useCallback } from 'react'

function Counter() {
	const [count, setCount] = useState(0);
	const [countOther, setCountOther] = useState(0);
	
	const increase = () =&gt; setCount(count + 1);
	const decrease = () =&gt; setCount(count - 1);
	
	const increaseOther = () =&gt; setCountOther(countOther + 1);
	const decreaseOther = () =&gt; setCountOther(countOther + 1);
	
	return (
			&lt;&gt;
				&lt;div&gt;Count: {count}&lt;/div&gt;
				&lt;button onClick={increase}&gt;+&lt;/button&gt;
				&lt;button onClick={increase}&gt;-&lt;/button&gt;

				&lt;div&gt;Count other: {countOther}&lt;/div&gt;
				&lt;button onClick={increaseOther}&gt;+&lt;/button&gt;
				&lt;button onClick={decreaseOther}&gt;-&lt;/button&gt;
			&lt;/&gt;
	)
}

export default Counter;
</code></pre>
<p>Điều này khá đơn giản, chúng ta có biến <strong>2 state</strong> nắm giữ số đếm và 4 hàm để thay đổi con số của 2 state trên.
Tuy nhiên, vấn đề ở đây là mỗi lần thành phần <code>Counter</code> này re-render, tất cả 4 hàm, <code>increase</code>, <code>decrease</code>, <code>increaseOther</code>, <code>decreaseOther</code> sẽ bị khởi tạo lại.</p>
<p>Chúng ta có thể thấy điều đó bằng cách sử dụng <code>Set</code> và thêm các hàm vào bên trong <code>Set</code> mỗi lần <code>Counter</code> re-render. Tại sao lại là <code>Set</code>. Đây là đối tượng lưu trữ phần tử có tính duy nhất, không trùng lặp.</p>
<pre><code class="language-jsx">import React, { useState, useCallback } from 'react'

const storeSet = new Set(); 

function Counter() {
	const [count, setCount] = useState(0);
	const [countOther, setCountOther] = useState(0);
	
	const increase = () =&gt; setCount(count + 1);
	const decrease = () =&gt; setCount(count - 1);
	
	const increaseOther = () =&gt; setCountOther(countOther + 1);
	const decreaseOther = () =&gt; setCountOther(countOther + 1);
	
	storeSet.add(increase);
	storeSet.add(decrease);
	storeSet.add(increaseOther);
	storeSet.add(decreaseOther);
	
	console.log(storeSet);
	
	return (
			&lt;&gt;
				&lt;div&gt;Count: {count}&lt;/div&gt;
				&lt;button onClick={increase}&gt;+&lt;/button&gt;
				&lt;button onClick={increase}&gt;-&lt;/button&gt;

				&lt;div&gt;Count other: {countOther}&lt;/div&gt;
				&lt;button onClick={increaseOther}&gt;+&lt;/button&gt;
				&lt;button onClick={decreaseOther}&gt;-&lt;/button&gt;
			&lt;/&gt;
	)
}

export default Counter;
</code></pre>
<p>Nào, bây giờ cùng kiểm tra thử nhé?. Mỗi lần bạn <strong>click</strong> vào bất kì nút tăng giảm sẽ thấy hiển thị giá trị của <code>storeSet</code>. Bạn sẽ thấy chúng tăng giá trị mỗi lần hiển thị, điều này cho thấy mỗi lần thành phần <code>re-render</code> sẽ tạo ra phiên bản hoàn toàn mới của các hạm được tạo ra.</p>
<p>Về cốt lõi, vấn đề này là do cách <code>JavaScript</code> xác định bình đẳng hàm.</p>
<h2 id='h2-function-equality-trong-javascript'>Function Equality trong Javascript</h2>
<p>Hãy xem ví dụ bên dưới trong đó chúng ta có hàm <code>factory</code> đang trả về một hàm khác.</p>
<pre><code class="language-js">function factory() {
	return (a,b) =&gt; a + b;
}

const functionA = factory();
const functionB = factory();

functionA(1,2); // 3
functionB(1,2); // 3

console.log(functionA === functionB) // false
console.log(functionA === functionA) // true
</code></pre>
<p>Tại đây, chúng ta tạo ra <code>functionA</code> và <code>functionB</code> thông qua <code>factory()</code>. Bạn có thể tìm hiểu thêm về hàm trong JavaScript thông qua <a href="https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function">First-class Function</a>, nghĩa là chúng được thể hiện dưới dạng các đối tượng thông thường. Đối tượng hàm có thể trả về một hàm khác (giống như hàm <code>factory</code>).</p>
<p>Bạn có thể thấy rằng, mặc dù <code>functionA</code> và <code>functionB</code> đều đến từ cùng một hàm <code>factory</code> và cùng làm một việc. chúng vốn dĩ là các đối tượng khác nhau, vì vậy, chúng không thể bằng nhau. Bất kì hàm JavaScript nào chỉ có thể bằng chính nó.</p>
<p>Bây giờ cùng trở lại với <strong>React</strong>, khi một thành phần <code>re-render</code>, mọi hàm bên trong nó sẽ bị <code>recreated</code>. <code>useCallback</code> làm cho nó có thể được <code>memoize</code> lại (hay là <strong>cache</strong>) <strong>instance</strong> hàm giữa những lần <code>render</code>. Điều này có ý nghĩa thay vì tạo lại đối tượng hàm mới, chúng ta có thể sử dụng lại cùng một đối tượng giữa các lần hiển thị.</p>
<p>Hãy cùng cập nhật cho các hàm increase/decrease sử dụng <code>useCallback</code></p>
<pre><code class="language-jsx">const increase = useCallback(() =&gt; setCount(count + 1), [count]);
const decrease = useCallback(() =&gt; setCount(count - 1), [count]);
	
const increaseOther = useCallback(() =&gt; setCountOther(countOther + 1), [countOther]);
const decreaseOther = useCallback(() =&gt; setCountOther(countOther + 1), [countOther]);
</code></pre>
<p>Lưu ý, cách chúng ta sử dụng tham số bên trong mảng, phụ thuộc vào một trong các tham số bên trong hàm <code>useCallback</code>. Miễn là các giá trị trong mảng phụ thuộc giống nhau giữa các lần hiển thị, <strong>React</strong> sẽ tiếp tục sử dụng phiên bản được <code>memoized</code> (cached) của hàm. Nếu các giá trị bên trong mảng phụ thuộc, thay đổi giữa các lần hiển thị, React sẽ tạo lại hàm.</p>
<p>Trong trường hợp này, khi chúng ta thử ấn button <code>increase</code> phía trên sau khi bọc các hàm setState lại bằng <code>useCallback</code> ,  kiểm tra hiển thị giá trị của <code>storeSet</code> chúng ta chỉ thấy duy nhất có một giá trị được tăng thêm, tiếp tục ấn button <code>increase</code> chúng ta vẫn không thấy giá trị thay đổi.</p>
<p>Mặc dù đây là một ví dụ rất đơn giản, nhưng chúng ta có thể thấy cách sử dụng <code>useCallback</code> để tối ưu hóa các thành phần có các chức năng phức tạp hoặc tốn nhiều tài nguyên.</p>
<h2 id='h2-khi-nao-khong-nen-su-dung-codeusecallbackcode'>Khi nào không nên sử dụng <code>useCallback</code></h2>
<p>Tuy nhiên, hãy đảm bảo rằng điều này không đi quá đà. <code>useCallback</code> cũng sỡ hữu nhược điểm,, chủ yếu là độ phức tạp của mã. Ở đây có rất nhiều trường hợp không hợp lý khi thêm <code>useCallback</code> và chúng ta phải chấp nhận để hàm khởi tạo lại. Như đã nói, <code>useCallback</code> cũng sở hữu nhược điểm về hiệu xuất, vì nó vẫn phải chạy trên mọi thành phần <code>render</code>.</p>
<p>Trong ví dụ này, <code>useCallback</code> thực chất sẽ không giúp tối ưu, vì chúng ta tạo đang tạo xử lý <code>handleClick</code> cho cả quá trình render của thành phần khác.</p>
<pre><code class="language-jsx">
const ComponentA = () =&gt; {
	const [count, setCount] = useState(0)
	const handleClick = useCallback(() =&gt; setCount(count + 1), [count]);
	
	return &lt;ButtonWrap onClick={handleClick} /&gt;
}

const ButtonWrap = ({children, ...props}) =&gt; {
	return &lt;button {...props}&gt;Button Children&lt;/button&gt;
}

</code></pre>
<p>Trong trường hợp này, <code>useCallback</code> sẽ không phát huy được nhiều tác dụng của nó.</p>
<p>Khi nghĩ về các nâng cấp hiệu xuất như sử dụng <code>useCallback</code>, luôn phải đo lường tốc độ của các thành phần component của bạn trước khi bắt đầu tối ưu hoá chúng. Việc tối ưu hoá không cần thiết sẽ khiến code của bạn trở nên rườm rà, phức tạp và có thể khó bảo trì về sau.</p>
<h2 id='h2-ket-luan'>Kết luận</h2>
<p><code>useCallback</code>  là một <code>react hook</code> mạnh mã để tối ưu hoá <strong>React component</strong> phức tạp bởi vì chúng sẽ lưu trữ lại các hàm giữa những lần render.</p>
<p>Trước khi làm việc với <code>useCallback</code>, đảm bảo bạn đã phân tích những điều sau:</p>
<ul>
<li>Tốc độ tăng có đảm bảo độ phức tạo của vẫn giữ được ở mức cần thiết ?</li>
<li>Sử dụng <code>useCallback</code> có đảm bảo tăng tốc độ cho thành phần được sử dụng?</li>
</ul>
</div><div class="space-y-2 mt-16"><div class="space-x-2 mb-2"><span class="font-semibold">Tag: </span><span style="min-width:50px" class="px-3 py-1 font-medium rounded-full inline-block text-sm bg-blue-100 text-blue-600">JavaScript</span><span style="min-width:50px" class="px-3 py-1 font-medium rounded-full inline-block text-sm bg-blue-100 text-blue-600">Frontend</span><span style="min-width:50px" class="px-3 py-1 font-medium rounded-full inline-block text-sm bg-blue-100 text-blue-600">Security</span></div><div class="mt-8 rounded-lg pr-6 py-4"><h2 class="text-md mb-4 font-semibold">Có thể bạn quan tâm</h2><ul class="list-disc pl-5"><li class="text-sm text-slate-300 font-medium mb-3"><a class="text-slate-400 hover:text-blue-600 transition-all duration-300" href="/posts/tim-hieu-phan-tu-dialog-trong-html">Tìm hiểu phần tử Dialog trong HTML</a></li><li class="text-sm text-slate-300 font-medium mb-3"><a class="text-slate-400 hover:text-blue-600 transition-all duration-300" href="/posts/su-dung-foreach-trong-javascript">Sử dụng forEach trong javascript</a></li><li class="text-sm text-slate-300 font-medium mb-3"><a class="text-slate-400 hover:text-blue-600 transition-all duration-300" href="/posts/huong-dan-su-dung-usecallback-trong-react">Hướng dẫn sử dụng useCallback trong React</a></li><li class="text-sm text-slate-300 font-medium mb-3"><a class="text-slate-400 hover:text-blue-600 transition-all duration-300" href="/posts/huong-dan-su-dung-usecallback-trong-react">Hướng dẫn sử dụng useCallback trong React</a></li><li class="text-sm text-slate-300 font-medium mb-3"><a class="text-slate-400 hover:text-blue-600 transition-all duration-300" href="/posts/xay-dung-ui-component-design-systems-danh-cho-lap-trinh-vien-frontend-phan-2">Xây dựng UI Component Design Systems dành cho lập trình viên Frontend (Phần 2)</a></li><li class="text-sm text-slate-300 font-medium mb-3"><a class="text-slate-400 hover:text-blue-600 transition-all duration-300" href="/posts/xay-dung-ui-component-design-systems-danh-cho-lap-trinh-vien-frontend-phan-2">Xây dựng UI Component Design Systems dành cho lập trình viên Frontend (Phần 2)</a></li><li class="text-sm text-slate-300 font-medium mb-3"><a class="text-slate-400 hover:text-blue-600 transition-all duration-300" href="/posts/promise-memoization-pattern">Promise Memoization Pattern</a></li><li class="text-sm text-slate-300 font-medium mb-3"><a class="text-slate-400 hover:text-blue-600 transition-all duration-300" href="/posts/css-grid-phan-1-tim-hieu-ve-grid">CSS Grid #1: Tìm hiểu về Grid</a></li><li class="text-sm text-slate-300 font-medium mb-3"><a class="text-slate-400 hover:text-blue-600 transition-all duration-300" href="/posts/cac-ky-thuat-viet-code-javascript-ma-ban-khong-the-khong-biet">Các kỹ thuật viết code javascript mà bạn không thể không biết</a></li><li class="text-sm text-slate-300 font-medium mb-3"><a class="text-slate-400 hover:text-blue-600 transition-all duration-300" href="/posts/csrf-protection-va-nhung-djieu-can-phai-biet">CSRF Protection và những điều cần phải biết</a></li></ul></div></div><div class="giscus" id="giscus" data-testid="giscus-test"></div></div></div></div></section></div><div id="portal-overlay"></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"postId":14,"title":"Hướng dẫn sử dụng useCallback trong React","views":11112,"thumbnail":"https://codestus.com/uploads/images/posts/3b9b3cd5-5376-4f5f-aa41-57dc9d46e045.png","slug":"huong-dan-su-dung-usecallback-trong-react","description":"React hooks là một phương thức quản lý state mới trong function components, được giới thiệu trong phiên bản React v16.8","content":"**React hooks** là một phương thức quản lý state mới trong function components, được giới thiệu trong phiên bản **React v16.8**. Với những hook như **useState**, **useEffect** và một số khác. Các nhà phát triển cuối cùng có thể làm việc với các **side effects** trong các thành phần chức năng.\r\n\r\nTrong bài viết lần này, chúng ta sẽ xem xét về **useCallback**, một trong những **hook** được giới thiệu từ bản cập nhật của **React**, và tìm hiểu xem làm thế nào để chúng ta sử dụng **useCallback** tốt.\r\n\r\n## Giới thiệu sơ về `useCallback`\r\n`useCallback` là được sử dụng để tối ưu quá trình **render** của **React functional components**. Nó sẽ rất hữu ích đối với trường hợp một thành phần (component) liên tục được hiển thị lại không cần thiết trong quá trình xử lý sự kiện người dùng và có hành vi chức năng phức tạp. Chúng ta sẽ xem xét thông qua ví dụ đơn giản về cách triển khai hook này để xem cách nó có thể giúp chúng ta đạt hiệu quả thế nào trong quá trình xử lý **re-rendering** của **component**.\r\n\r\nHãy nhớ rằng **React** đã rất nhanh, tối ưu hiệu xuất chỉ nên sử dụng cho những component có khả năng chậm, xử lý tác vụ nặng. Khi đó, chúng ta sẽ xem xét xử dụng `useCallback` làm một phần hỗ trợ tối ưu hiện xuất trong các hook.\r\n\r\nNào, bây giờ hãy xem xét ví dụ đơn giản qua `Counter` Component nhé:\r\n\r\n```jsx\r\nimport React, { useState, useCallback } from 'react'\r\n\r\nfunction Counter() {\r\n\tconst [count, setCount] = useState(0);\r\n\tconst [countOther, setCountOther] = useState(0);\r\n\t\r\n\tconst increase = () =\u003e setCount(count + 1);\r\n\tconst decrease = () =\u003e setCount(count - 1);\r\n\t\r\n\tconst increaseOther = () =\u003e setCountOther(countOther + 1);\r\n\tconst decreaseOther = () =\u003e setCountOther(countOther + 1);\r\n\t\r\n\treturn (\r\n\t\t\t\u003c\u003e\r\n\t\t\t\t\u003cdiv\u003eCount: {count}\u003c/div\u003e\r\n\t\t\t\t\u003cbutton onClick={increase}\u003e+\u003c/button\u003e\r\n\t\t\t\t\u003cbutton onClick={increase}\u003e-\u003c/button\u003e\r\n\r\n\t\t\t\t\u003cdiv\u003eCount other: {countOther}\u003c/div\u003e\r\n\t\t\t\t\u003cbutton onClick={increaseOther}\u003e+\u003c/button\u003e\r\n\t\t\t\t\u003cbutton onClick={decreaseOther}\u003e-\u003c/button\u003e\r\n\t\t\t\u003c/\u003e\r\n\t)\r\n}\r\n\r\nexport default Counter;\r\n```\r\n\r\nĐiều này khá đơn giản, chúng ta có biến **2 state** nắm giữ số đếm và 4 hàm để thay đổi con số của 2 state trên.\r\nTuy nhiên, vấn đề ở đây là mỗi lần thành phần `Counter` này re-render, tất cả 4 hàm, `increase`, `decrease`, `increaseOther`, `decreaseOther` sẽ bị khởi tạo lại.\r\n\r\nChúng ta có thể thấy điều đó bằng cách sử dụng `Set` và thêm các hàm vào bên trong `Set` mỗi lần `Counter` re-render. Tại sao lại là `Set`. Đây là đối tượng lưu trữ phần tử có tính duy nhất, không trùng lặp.\r\n\r\n```jsx\r\nimport React, { useState, useCallback } from 'react'\r\n\r\nconst storeSet = new Set(); \r\n\r\nfunction Counter() {\r\n\tconst [count, setCount] = useState(0);\r\n\tconst [countOther, setCountOther] = useState(0);\r\n\t\r\n\tconst increase = () =\u003e setCount(count + 1);\r\n\tconst decrease = () =\u003e setCount(count - 1);\r\n\t\r\n\tconst increaseOther = () =\u003e setCountOther(countOther + 1);\r\n\tconst decreaseOther = () =\u003e setCountOther(countOther + 1);\r\n\t\r\n\tstoreSet.add(increase);\r\n\tstoreSet.add(decrease);\r\n\tstoreSet.add(increaseOther);\r\n\tstoreSet.add(decreaseOther);\r\n\t\r\n\tconsole.log(storeSet);\r\n\t\r\n\treturn (\r\n\t\t\t\u003c\u003e\r\n\t\t\t\t\u003cdiv\u003eCount: {count}\u003c/div\u003e\r\n\t\t\t\t\u003cbutton onClick={increase}\u003e+\u003c/button\u003e\r\n\t\t\t\t\u003cbutton onClick={increase}\u003e-\u003c/button\u003e\r\n\r\n\t\t\t\t\u003cdiv\u003eCount other: {countOther}\u003c/div\u003e\r\n\t\t\t\t\u003cbutton onClick={increaseOther}\u003e+\u003c/button\u003e\r\n\t\t\t\t\u003cbutton onClick={decreaseOther}\u003e-\u003c/button\u003e\r\n\t\t\t\u003c/\u003e\r\n\t)\r\n}\r\n\r\nexport default Counter;\r\n```\r\n\r\nNào, bây giờ cùng kiểm tra thử nhé?. Mỗi lần bạn **click** vào bất kì nút tăng giảm sẽ thấy hiển thị giá trị của `storeSet`. Bạn sẽ thấy chúng tăng giá trị mỗi lần hiển thị, điều này cho thấy mỗi lần thành phần `re-render` sẽ tạo ra phiên bản hoàn toàn mới của các hạm được tạo ra.\r\n\r\nVề cốt lõi, vấn đề này là do cách `JavaScript` xác định bình đẳng hàm.\r\n\r\n## Function Equality trong Javascript\r\n\r\nHãy xem ví dụ bên dưới trong đó chúng ta có hàm `factory` đang trả về một hàm khác.\r\n\r\n```js\r\nfunction factory() {\r\n\treturn (a,b) =\u003e a + b;\r\n}\r\n\r\nconst functionA = factory();\r\nconst functionB = factory();\r\n\r\nfunctionA(1,2); // 3\r\nfunctionB(1,2); // 3\r\n\r\nconsole.log(functionA === functionB) // false\r\nconsole.log(functionA === functionA) // true\r\n```\r\n\r\nTại đây, chúng ta tạo ra `functionA` và `functionB` thông qua `factory()`. Bạn có thể tìm hiểu thêm về hàm trong JavaScript thông qua [First-class Function](https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function), nghĩa là chúng được thể hiện dưới dạng các đối tượng thông thường. Đối tượng hàm có thể trả về một hàm khác (giống như hàm `factory`).\r\n\r\nBạn có thể thấy rằng, mặc dù `functionA` và `functionB` đều đến từ cùng một hàm `factory` và cùng làm một việc. chúng vốn dĩ là các đối tượng khác nhau, vì vậy, chúng không thể bằng nhau. Bất kì hàm JavaScript nào chỉ có thể bằng chính nó.\r\n\r\nBây giờ cùng trở lại với **React**, khi một thành phần `re-render`, mọi hàm bên trong nó sẽ bị `recreated`. `useCallback` làm cho nó có thể được `memoize` lại (hay là **cache**) **instance** hàm giữa những lần `render`. Điều này có ý nghĩa thay vì tạo lại đối tượng hàm mới, chúng ta có thể sử dụng lại cùng một đối tượng giữa các lần hiển thị.\r\n\r\nHãy cùng cập nhật cho các hàm increase/decrease sử dụng `useCallback`\r\n\r\n```jsx\r\nconst increase = useCallback(() =\u003e setCount(count + 1), [count]);\r\nconst decrease = useCallback(() =\u003e setCount(count - 1), [count]);\r\n\t\r\nconst increaseOther = useCallback(() =\u003e setCountOther(countOther + 1), [countOther]);\r\nconst decreaseOther = useCallback(() =\u003e setCountOther(countOther + 1), [countOther]);\r\n```\r\n\r\nLưu ý, cách chúng ta sử dụng tham số bên trong mảng, phụ thuộc vào một trong các tham số bên trong hàm `useCallback`. Miễn là các giá trị trong mảng phụ thuộc giống nhau giữa các lần hiển thị, **React** sẽ tiếp tục sử dụng phiên bản được `memoized` (cached) của hàm. Nếu các giá trị bên trong mảng phụ thuộc, thay đổi giữa các lần hiển thị, React sẽ tạo lại hàm.\r\n\r\nTrong trường hợp này, khi chúng ta thử ấn button `increase` phía trên sau khi bọc các hàm setState lại bằng `useCallback` ,  kiểm tra hiển thị giá trị của `storeSet` chúng ta chỉ thấy duy nhất có một giá trị được tăng thêm, tiếp tục ấn button `increase` chúng ta vẫn không thấy giá trị thay đổi. \r\n\r\nMặc dù đây là một ví dụ rất đơn giản, nhưng chúng ta có thể thấy cách sử dụng `useCallback` để tối ưu hóa các thành phần có các chức năng phức tạp hoặc tốn nhiều tài nguyên.\r\n\r\n## Khi nào không nên sử dụng `useCallback`\r\nTuy nhiên, hãy đảm bảo rằng điều này không đi quá đà. `useCallback` cũng sỡ hữu nhược điểm,, chủ yếu là độ phức tạp của mã. Ở đây có rất nhiều trường hợp không hợp lý khi thêm `useCallback` và chúng ta phải chấp nhận để hàm khởi tạo lại. Như đã nói, `useCallback` cũng sở hữu nhược điểm về hiệu xuất, vì nó vẫn phải chạy trên mọi thành phần `render`.\r\n\r\nTrong ví dụ này, `useCallback` thực chất sẽ không giúp tối ưu, vì chúng ta tạo đang tạo xử lý `handleClick` cho cả quá trình render của thành phần khác.\r\n\r\n```jsx\r\n\r\nconst ComponentA = () =\u003e {\r\n\tconst [count, setCount] = useState(0)\r\n\tconst handleClick = useCallback(() =\u003e setCount(count + 1), [count]);\r\n\t\r\n\treturn \u003cButtonWrap onClick={handleClick} /\u003e\r\n}\r\n\r\nconst ButtonWrap = ({children, ...props}) =\u003e {\r\n\treturn \u003cbutton {...props}\u003eButton Children\u003c/button\u003e\r\n}\r\n\r\n```\r\n\r\nTrong trường hợp này, `useCallback` sẽ không phát huy được nhiều tác dụng của nó.\r\n\r\nKhi nghĩ về các nâng cấp hiệu xuất như sử dụng `useCallback`, luôn phải đo lường tốc độ của các thành phần component của bạn trước khi bắt đầu tối ưu hoá chúng. Việc tối ưu hoá không cần thiết sẽ khiến code của bạn trở nên rườm rà, phức tạp và có thể khó bảo trì về sau.\r\n\r\n## Kết luận\r\n`useCallback`  là một `react hook` mạnh mã để tối ưu hoá **React component** phức tạp bởi vì chúng sẽ lưu trữ lại các hàm giữa những lần render.\r\n\r\nTrước khi làm việc với `useCallback`, đảm bảo bạn đã phân tích những điều sau:\r\n- Tốc độ tăng có đảm bảo độ phức tạo của vẫn giữ được ở mức cần thiết ?\r\n- Sử dụng `useCallback` có đảm bảo tăng tốc độ cho thành phần được sử dụng?","userId":2,"status":1,"created_at":"2021-02-13T17:09:29.000000Z","updated_at":"2022-03-31T08:30:02.000000Z","publish_at":"2021-02-14 00:09:29","tags":[{"tagId":1,"name":"JavaScript","slug":"javascript","description":"JavaScript là ngôn ngữ lập trình động. Nhẹ và phổ biến, hầu như hiện nay được sử dụng trên hầu hết các trang web. Là ngôn ngữ có thể làm việc phía máy khách và hiện tại có thể xử lý ở phía máy chủ. Nó là môn ngôn ngữ thông dụng và mang không nhiều tính OOP.","created_at":"2021-01-22T10:11:34.000000Z","updated_at":"2021-01-22T10:11:34.000000Z"},{"tagId":3,"name":"Frontend","slug":"frontend","description":null,"created_at":"2021-01-22T10:49:00.000000Z","updated_at":"2021-01-22T10:50:07.000000Z"},{"tagId":5,"name":"Security","slug":"secure","description":null,"created_at":"2021-02-12T21:54:09.000000Z","updated_at":"2022-02-12T05:17:12.000000Z"}],"user":{"userId":2,"name":"Trọng Dương Đức","email":"duongductrong06@gmail.com","email_verified_at":"2021-06-01T03:02:35.000000Z","created_at":"2021-06-01T03:02:35.000000Z","updated_at":"2021-06-01T03:02:35.000000Z","avatar":"https://lh3.googleusercontent.com/a-/AOh14GjOet0wOfzD6Ri6zDQjg-lnxzlnrwxq6e4vByoIjQ=s96-c"},"content_html":"\u003cp\u003e\u003cstrong\u003eReact hooks\u003c/strong\u003e là một phương thức quản lý state mới trong function components, được giới thiệu trong phiên bản \u003cstrong\u003eReact v16.8\u003c/strong\u003e. Với những hook như \u003cstrong\u003euseState\u003c/strong\u003e, \u003cstrong\u003euseEffect\u003c/strong\u003e và một số khác. Các nhà phát triển cuối cùng có thể làm việc với các \u003cstrong\u003eside effects\u003c/strong\u003e trong các thành phần chức năng.\u003c/p\u003e\n\u003cp\u003eTrong bài viết lần này, chúng ta sẽ xem xét về \u003cstrong\u003euseCallback\u003c/strong\u003e, một trong những \u003cstrong\u003ehook\u003c/strong\u003e được giới thiệu từ bản cập nhật của \u003cstrong\u003eReact\u003c/strong\u003e, và tìm hiểu xem làm thế nào để chúng ta sử dụng \u003cstrong\u003euseCallback\u003c/strong\u003e tốt.\u003c/p\u003e\n\u003ch2 id='h2-gioi-thieu-so-ve-codeusecallbackcode'\u003eGiới thiệu sơ về \u003ccode\u003euseCallback\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003euseCallback\u003c/code\u003e là được sử dụng để tối ưu quá trình \u003cstrong\u003erender\u003c/strong\u003e của \u003cstrong\u003eReact functional components\u003c/strong\u003e. Nó sẽ rất hữu ích đối với trường hợp một thành phần (component) liên tục được hiển thị lại không cần thiết trong quá trình xử lý sự kiện người dùng và có hành vi chức năng phức tạp. Chúng ta sẽ xem xét thông qua ví dụ đơn giản về cách triển khai hook này để xem cách nó có thể giúp chúng ta đạt hiệu quả thế nào trong quá trình xử lý \u003cstrong\u003ere-rendering\u003c/strong\u003e của \u003cstrong\u003ecomponent\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eHãy nhớ rằng \u003cstrong\u003eReact\u003c/strong\u003e đã rất nhanh, tối ưu hiệu xuất chỉ nên sử dụng cho những component có khả năng chậm, xử lý tác vụ nặng. Khi đó, chúng ta sẽ xem xét xử dụng \u003ccode\u003euseCallback\u003c/code\u003e làm một phần hỗ trợ tối ưu hiện xuất trong các hook.\u003c/p\u003e\n\u003cp\u003eNào, bây giờ hãy xem xét ví dụ đơn giản qua \u003ccode\u003eCounter\u003c/code\u003e Component nhé:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-jsx\"\u003eimport React, { useState, useCallback } from 'react'\n\nfunction Counter() {\n\tconst [count, setCount] = useState(0);\n\tconst [countOther, setCountOther] = useState(0);\n\t\n\tconst increase = () =\u0026gt; setCount(count + 1);\n\tconst decrease = () =\u0026gt; setCount(count - 1);\n\t\n\tconst increaseOther = () =\u0026gt; setCountOther(countOther + 1);\n\tconst decreaseOther = () =\u0026gt; setCountOther(countOther + 1);\n\t\n\treturn (\n\t\t\t\u0026lt;\u0026gt;\n\t\t\t\t\u0026lt;div\u0026gt;Count: {count}\u0026lt;/div\u0026gt;\n\t\t\t\t\u0026lt;button onClick={increase}\u0026gt;+\u0026lt;/button\u0026gt;\n\t\t\t\t\u0026lt;button onClick={increase}\u0026gt;-\u0026lt;/button\u0026gt;\n\n\t\t\t\t\u0026lt;div\u0026gt;Count other: {countOther}\u0026lt;/div\u0026gt;\n\t\t\t\t\u0026lt;button onClick={increaseOther}\u0026gt;+\u0026lt;/button\u0026gt;\n\t\t\t\t\u0026lt;button onClick={decreaseOther}\u0026gt;-\u0026lt;/button\u0026gt;\n\t\t\t\u0026lt;/\u0026gt;\n\t)\n}\n\nexport default Counter;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eĐiều này khá đơn giản, chúng ta có biến \u003cstrong\u003e2 state\u003c/strong\u003e nắm giữ số đếm và 4 hàm để thay đổi con số của 2 state trên.\nTuy nhiên, vấn đề ở đây là mỗi lần thành phần \u003ccode\u003eCounter\u003c/code\u003e này re-render, tất cả 4 hàm, \u003ccode\u003eincrease\u003c/code\u003e, \u003ccode\u003edecrease\u003c/code\u003e, \u003ccode\u003eincreaseOther\u003c/code\u003e, \u003ccode\u003edecreaseOther\u003c/code\u003e sẽ bị khởi tạo lại.\u003c/p\u003e\n\u003cp\u003eChúng ta có thể thấy điều đó bằng cách sử dụng \u003ccode\u003eSet\u003c/code\u003e và thêm các hàm vào bên trong \u003ccode\u003eSet\u003c/code\u003e mỗi lần \u003ccode\u003eCounter\u003c/code\u003e re-render. Tại sao lại là \u003ccode\u003eSet\u003c/code\u003e. Đây là đối tượng lưu trữ phần tử có tính duy nhất, không trùng lặp.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-jsx\"\u003eimport React, { useState, useCallback } from 'react'\n\nconst storeSet = new Set(); \n\nfunction Counter() {\n\tconst [count, setCount] = useState(0);\n\tconst [countOther, setCountOther] = useState(0);\n\t\n\tconst increase = () =\u0026gt; setCount(count + 1);\n\tconst decrease = () =\u0026gt; setCount(count - 1);\n\t\n\tconst increaseOther = () =\u0026gt; setCountOther(countOther + 1);\n\tconst decreaseOther = () =\u0026gt; setCountOther(countOther + 1);\n\t\n\tstoreSet.add(increase);\n\tstoreSet.add(decrease);\n\tstoreSet.add(increaseOther);\n\tstoreSet.add(decreaseOther);\n\t\n\tconsole.log(storeSet);\n\t\n\treturn (\n\t\t\t\u0026lt;\u0026gt;\n\t\t\t\t\u0026lt;div\u0026gt;Count: {count}\u0026lt;/div\u0026gt;\n\t\t\t\t\u0026lt;button onClick={increase}\u0026gt;+\u0026lt;/button\u0026gt;\n\t\t\t\t\u0026lt;button onClick={increase}\u0026gt;-\u0026lt;/button\u0026gt;\n\n\t\t\t\t\u0026lt;div\u0026gt;Count other: {countOther}\u0026lt;/div\u0026gt;\n\t\t\t\t\u0026lt;button onClick={increaseOther}\u0026gt;+\u0026lt;/button\u0026gt;\n\t\t\t\t\u0026lt;button onClick={decreaseOther}\u0026gt;-\u0026lt;/button\u0026gt;\n\t\t\t\u0026lt;/\u0026gt;\n\t)\n}\n\nexport default Counter;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNào, bây giờ cùng kiểm tra thử nhé?. Mỗi lần bạn \u003cstrong\u003eclick\u003c/strong\u003e vào bất kì nút tăng giảm sẽ thấy hiển thị giá trị của \u003ccode\u003estoreSet\u003c/code\u003e. Bạn sẽ thấy chúng tăng giá trị mỗi lần hiển thị, điều này cho thấy mỗi lần thành phần \u003ccode\u003ere-render\u003c/code\u003e sẽ tạo ra phiên bản hoàn toàn mới của các hạm được tạo ra.\u003c/p\u003e\n\u003cp\u003eVề cốt lõi, vấn đề này là do cách \u003ccode\u003eJavaScript\u003c/code\u003e xác định bình đẳng hàm.\u003c/p\u003e\n\u003ch2 id='h2-function-equality-trong-javascript'\u003eFunction Equality trong Javascript\u003c/h2\u003e\n\u003cp\u003eHãy xem ví dụ bên dưới trong đó chúng ta có hàm \u003ccode\u003efactory\u003c/code\u003e đang trả về một hàm khác.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction factory() {\n\treturn (a,b) =\u0026gt; a + b;\n}\n\nconst functionA = factory();\nconst functionB = factory();\n\nfunctionA(1,2); // 3\nfunctionB(1,2); // 3\n\nconsole.log(functionA === functionB) // false\nconsole.log(functionA === functionA) // true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTại đây, chúng ta tạo ra \u003ccode\u003efunctionA\u003c/code\u003e và \u003ccode\u003efunctionB\u003c/code\u003e thông qua \u003ccode\u003efactory()\u003c/code\u003e. Bạn có thể tìm hiểu thêm về hàm trong JavaScript thông qua \u003ca href=\"https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function\"\u003eFirst-class Function\u003c/a\u003e, nghĩa là chúng được thể hiện dưới dạng các đối tượng thông thường. Đối tượng hàm có thể trả về một hàm khác (giống như hàm \u003ccode\u003efactory\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eBạn có thể thấy rằng, mặc dù \u003ccode\u003efunctionA\u003c/code\u003e và \u003ccode\u003efunctionB\u003c/code\u003e đều đến từ cùng một hàm \u003ccode\u003efactory\u003c/code\u003e và cùng làm một việc. chúng vốn dĩ là các đối tượng khác nhau, vì vậy, chúng không thể bằng nhau. Bất kì hàm JavaScript nào chỉ có thể bằng chính nó.\u003c/p\u003e\n\u003cp\u003eBây giờ cùng trở lại với \u003cstrong\u003eReact\u003c/strong\u003e, khi một thành phần \u003ccode\u003ere-render\u003c/code\u003e, mọi hàm bên trong nó sẽ bị \u003ccode\u003erecreated\u003c/code\u003e. \u003ccode\u003euseCallback\u003c/code\u003e làm cho nó có thể được \u003ccode\u003ememoize\u003c/code\u003e lại (hay là \u003cstrong\u003ecache\u003c/strong\u003e) \u003cstrong\u003einstance\u003c/strong\u003e hàm giữa những lần \u003ccode\u003erender\u003c/code\u003e. Điều này có ý nghĩa thay vì tạo lại đối tượng hàm mới, chúng ta có thể sử dụng lại cùng một đối tượng giữa các lần hiển thị.\u003c/p\u003e\n\u003cp\u003eHãy cùng cập nhật cho các hàm increase/decrease sử dụng \u003ccode\u003euseCallback\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-jsx\"\u003econst increase = useCallback(() =\u0026gt; setCount(count + 1), [count]);\nconst decrease = useCallback(() =\u0026gt; setCount(count - 1), [count]);\n\t\nconst increaseOther = useCallback(() =\u0026gt; setCountOther(countOther + 1), [countOther]);\nconst decreaseOther = useCallback(() =\u0026gt; setCountOther(countOther + 1), [countOther]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLưu ý, cách chúng ta sử dụng tham số bên trong mảng, phụ thuộc vào một trong các tham số bên trong hàm \u003ccode\u003euseCallback\u003c/code\u003e. Miễn là các giá trị trong mảng phụ thuộc giống nhau giữa các lần hiển thị, \u003cstrong\u003eReact\u003c/strong\u003e sẽ tiếp tục sử dụng phiên bản được \u003ccode\u003ememoized\u003c/code\u003e (cached) của hàm. Nếu các giá trị bên trong mảng phụ thuộc, thay đổi giữa các lần hiển thị, React sẽ tạo lại hàm.\u003c/p\u003e\n\u003cp\u003eTrong trường hợp này, khi chúng ta thử ấn button \u003ccode\u003eincrease\u003c/code\u003e phía trên sau khi bọc các hàm setState lại bằng \u003ccode\u003euseCallback\u003c/code\u003e ,  kiểm tra hiển thị giá trị của \u003ccode\u003estoreSet\u003c/code\u003e chúng ta chỉ thấy duy nhất có một giá trị được tăng thêm, tiếp tục ấn button \u003ccode\u003eincrease\u003c/code\u003e chúng ta vẫn không thấy giá trị thay đổi.\u003c/p\u003e\n\u003cp\u003eMặc dù đây là một ví dụ rất đơn giản, nhưng chúng ta có thể thấy cách sử dụng \u003ccode\u003euseCallback\u003c/code\u003e để tối ưu hóa các thành phần có các chức năng phức tạp hoặc tốn nhiều tài nguyên.\u003c/p\u003e\n\u003ch2 id='h2-khi-nao-khong-nen-su-dung-codeusecallbackcode'\u003eKhi nào không nên sử dụng \u003ccode\u003euseCallback\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eTuy nhiên, hãy đảm bảo rằng điều này không đi quá đà. \u003ccode\u003euseCallback\u003c/code\u003e cũng sỡ hữu nhược điểm,, chủ yếu là độ phức tạp của mã. Ở đây có rất nhiều trường hợp không hợp lý khi thêm \u003ccode\u003euseCallback\u003c/code\u003e và chúng ta phải chấp nhận để hàm khởi tạo lại. Như đã nói, \u003ccode\u003euseCallback\u003c/code\u003e cũng sở hữu nhược điểm về hiệu xuất, vì nó vẫn phải chạy trên mọi thành phần \u003ccode\u003erender\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eTrong ví dụ này, \u003ccode\u003euseCallback\u003c/code\u003e thực chất sẽ không giúp tối ưu, vì chúng ta tạo đang tạo xử lý \u003ccode\u003ehandleClick\u003c/code\u003e cho cả quá trình render của thành phần khác.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-jsx\"\u003e\nconst ComponentA = () =\u0026gt; {\n\tconst [count, setCount] = useState(0)\n\tconst handleClick = useCallback(() =\u0026gt; setCount(count + 1), [count]);\n\t\n\treturn \u0026lt;ButtonWrap onClick={handleClick} /\u0026gt;\n}\n\nconst ButtonWrap = ({children, ...props}) =\u0026gt; {\n\treturn \u0026lt;button {...props}\u0026gt;Button Children\u0026lt;/button\u0026gt;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTrong trường hợp này, \u003ccode\u003euseCallback\u003c/code\u003e sẽ không phát huy được nhiều tác dụng của nó.\u003c/p\u003e\n\u003cp\u003eKhi nghĩ về các nâng cấp hiệu xuất như sử dụng \u003ccode\u003euseCallback\u003c/code\u003e, luôn phải đo lường tốc độ của các thành phần component của bạn trước khi bắt đầu tối ưu hoá chúng. Việc tối ưu hoá không cần thiết sẽ khiến code của bạn trở nên rườm rà, phức tạp và có thể khó bảo trì về sau.\u003c/p\u003e\n\u003ch2 id='h2-ket-luan'\u003eKết luận\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003euseCallback\u003c/code\u003e  là một \u003ccode\u003ereact hook\u003c/code\u003e mạnh mã để tối ưu hoá \u003cstrong\u003eReact component\u003c/strong\u003e phức tạp bởi vì chúng sẽ lưu trữ lại các hàm giữa những lần render.\u003c/p\u003e\n\u003cp\u003eTrước khi làm việc với \u003ccode\u003euseCallback\u003c/code\u003e, đảm bảo bạn đã phân tích những điều sau:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTốc độ tăng có đảm bảo độ phức tạo của vẫn giữ được ở mức cần thiết ?\u003c/li\u003e\n\u003cli\u003eSử dụng \u003ccode\u003euseCallback\u003c/code\u003e có đảm bảo tăng tốc độ cho thành phần được sử dụng?\u003c/li\u003e\n\u003c/ul\u003e\n","table_of_contents":[{"start":"\u003ch2\u003e","text":"Giới thiệu sơ về \u003ccode\u003euseCallback\u003c/code\u003e","end":"\u003c/h2\u003e","full":"\u003ch2\u003eGiới thiệu sơ về \u003ccode\u003euseCallback\u003c/code\u003e\u003c/h2\u003e","id":"h2-gioi-thieu-so-ve-codeusecallbackcode","type":"2"},{"start":"\u003ch2\u003e","text":"Function Equality trong Javascript","end":"\u003c/h2\u003e","full":"\u003ch2\u003eFunction Equality trong Javascript\u003c/h2\u003e","id":"h2-function-equality-trong-javascript","type":"2"},{"start":"\u003ch2\u003e","text":"Khi nào không nên sử dụng \u003ccode\u003euseCallback\u003c/code\u003e","end":"\u003c/h2\u003e","full":"\u003ch2\u003eKhi nào không nên sử dụng \u003ccode\u003euseCallback\u003c/code\u003e\u003c/h2\u003e","id":"h2-khi-nao-khong-nen-su-dung-codeusecallbackcode","type":"2"},{"start":"\u003ch2\u003e","text":"Kết luận","end":"\u003c/h2\u003e","full":"\u003ch2\u003eKết luận\u003c/h2\u003e","id":"h2-ket-luan","type":"2"}]},"relatedPosts":[{"postId":8,"title":"Tìm hiểu phần tử Dialog trong HTML","views":1814,"thumbnail":"https://res.cloudinary.com/xskill/image/upload/v1613836880/codestus/vhbteskepkxvzod2n3h6.png","slug":"tim-hieu-phan-tu-dialog-trong-html","description":"Diablog (được biết đến là một phương thức hộp thoại được cung cấp sẵn trong phiên bản HTML5) là một hộp thoại cho trang web. Nó cũng được gọi là Modal dialog","content":"**Diablog** (được biết đến là một hộp thoại được cung cấp sẵn trong phiên bản **HTML5**) là hộp thoại được cung cắp sẵn cho trang web. Hay còn được gọi là **Modal dialog**. Khi hiển thị, hộp thoại sẽ che khuất phần nội dung của trang web bên dưới. Mục đích để ngăn chặn tương tác của người dùng phần còn lại của nội dung trang web.\r\n\r\nBên dưới đây là hình ảnh ví dụ điển hình về hộp thoại **Dialog**. Nền đen bên dưới hộp thoại được gọi là `backdrop cover`\r\n\r\n![Hình ảnh minh hoạ về modal dialog](https://codestus.com/uploads/images/posts/vi_du_modal13_1-Bootstrap-modal-custom-size.png)\r\n\r\nTrong bài viết này, chúng ta sẽ tìm hiểu về thẻ `\u003cdialog\u003e` trong HTML và cùng xem cách sử dụng nó. Chúng ta cũng sẽ tìm hiểu về một số thiếu sót và cuối cùng, hãy cùng xác nhận xem nó đã đủ tiêu chuẩn để áp dụng vào ứng dụng của bạn chưa.\r\n\r\n## Nhìn chung về `\u003cdialog\u003e`\r\nPhần tử `\u003cdialog\u003e` đại diện cho `dialogbox` có một số thuộc tính thuộc tính đặt biệt để kích hoạt\r\n- **open**: Thuộc tính này chỉ ra trạng thái kích hoạt của hộp thoại. Khi thuộc tính này không được gán vào thẻ, hộp thoại sẽ không được hiển thị cho người dùng.\r\n\r\n```html\r\n\u003cdialog\u003e\r\nNgười dùng không thể thấy hộp thoại này\r\n\u003c/dialog\u003e\r\n\r\n\u003cdialog open\u003e\r\nNgười dùng có thể thấy hộp thoại này\r\n\u003c/dialog\u003e\r\n```\r\n\r\nỞ tại thời điểm của bài viết này, `\u003cdialog\u003e` đã được hỗ trợ trên các phiên bản trình duyệt.\r\n- **Chrome**: từ 37+\r\n- **Edge**: từ 79+\r\n- **Firefox**: từ 53+\r\n- **Safari**: Không hỗ trợ\r\n\r\nTìm hiểu thêm về:  [**Dialog**](https://developer.mozilla.org/vi/docs/Web/HTML/Element/dialog)\r\n\r\n## `\u003cDialog\u003e` APIs\r\nTrong JavaScript, bạn cũng có thể kích hoạt trạng thái bật tắt của dialog bằng hai phương thức sau.\r\n\r\n```js\r\nconst dialog = document.querySelector(\"dialog\");\r\n\r\n// Hiển thị\r\ndialog.show();\r\n\r\n// Ẩn\r\ndialog.close();\r\n```\r\n\r\nHộp thoại xuất hiện mặc định với các thuộc tính CSS cơ bản đã được cung cấp như **margin**, **border**, etc, có thể dễ dàng tuỳ chỉnh bằng **CSS**.\r\n\r\nnào, hãy cùng xem ví dụ bên dưới về phần tử **dialog** trong **HTML5**.\r\n\r\nXem thu73 demo: [Demo on Codepen](https://codepen.io/codestus/pen/jOVEmpm)\r\n\r\n## Sử dụng showModal() thay cho show()\r\nMột trong những điều mong muốn khi xây dựng hộp thoại, là cách bạn xây dựng phông nền để người dùng không thể tương tác với phần còn lại của trang web. Phương thức **dialog.showModal()** đã tự động thực hiện việc đó thông qua việc bạn kích hoạt nó trong lệnh **JavaScript**.\r\n\r\nMặc định, **backdrop** của **dialog** sẽ là một lớp **background** màu đen được làm mờ. Ngoài ra bạn cũng có thể tuỳ chỉnh lại màu nền này thông qua **::backdrop** **pseudo-element**.\r\n\r\nVí dụ thay thế phương thức **show()** bằng **showModal()**.\r\n\r\nXem thử demo: [Demo on Codepen](https://codepen.io/codestus/pen/RwoNgGa)\r\n\r\n## Tuỳ chỉnh thêm\r\nBên trên là sơ bộ về cách hoạt động của thẻ `\u003cdialog\u003e` trong **HTML5**.Ngoài ra, bạn có thể thêm các **sự kiện Escape(ESC)** để lắng nghe hành động tắt **hộp thoại**, **Thêm các hiệu ứng** để chúng hoạt động thêm sinh động hơn.\r\n\r\nNhưng hiện tại, **Dialog** vẫn chưa hỗ trợ hầu hết các trình duyệt, vậy nên các bạn cũng nên cân nhắc việc sử dụng trước khi áp dụng vào dự án thực tế nhé.\r\n\r\n\u003cscript async src=\"https://cpwebassets.codepen.io/assets/embed/ei.js\"\u003e\u003c/script\u003e","userId":2,"status":1,"created_at":"2021-01-30T18:50:26.000000Z","updated_at":"2022-03-31T08:00:01.000000Z","publish_at":"2021-01-31 01:50:26"},{"postId":10,"title":"Sử dụng forEach trong javascript","views":2111,"thumbnail":"https://res.cloudinary.com/xskill/image/upload/v1613836790/codestus/nursugvdaxvh025gagyg.png","slug":"su-dung-foreach-trong-javascript","description":"Khi làm việc với mảng bạn thường làm gì, lặp qua một mảng? \r\nTrong JavaScript, chúng ta có thể sử dụng một số phương thức được cung cấp như map, reduce, etc để lặp mảng","content":"Khi làm việc với mảng bạn thường làm gì, lặp qua một mảng? \r\n\r\nTrong JavaScript, chúng ta có thể sử dụng một số phương thức được cung cấp như `map`, `reduce`, etc để lặp mảng. Nhưng, trong phạm vi bài viết này, ta chỉ làm việc với `forEach` chứ không phải 2 phương thức đã nhắc đến. Chúng ta sẽ tìm hiểu về cách sử dụng phương thức `forEach`, phạm vi áp dụng, các đối tượng thường được áp dụng\r\n\r\n## Cơ bản về forEach\r\n`forEach` là phương thức lặp qua từng phần tử của mảng theo thứ tự tăng dần mà không làm thay đổi kết cấu của mảng, nhận vào một **callback** đảm nhiệm nhiệm vụ lặp qua từng phần tử của mảng được cung cấp, có 3 tham số chính được cung cấp là **item, index, array**.\r\n\r\n- **item**: Giá trị của phần tử trong mảng\r\n- **index**: Vị trí của phần tử trong mảng\r\n- **array**: Mảng gốc đang được lặp từ **forEach**\r\n\r\n```js\r\narray.forEach(callback[, thisArg]);\r\n```\r\n\r\nNào bây giờ hãy xem cách hoạt động của **forEach**.\r\n\r\nGiả sử trường hợp chúng ta nhận được mảng danh sách trái cây như sau\r\n\r\n```js\r\nconst fruits = [\"Apple\", \"Orange\", \"Banana\", \"Mango\"];\r\n```\r\n\r\nChúng ta sẽ lặp qua mảng `fruits` và `console.log` các từng phần tử trong mảng với forEach bằng cách:\r\n\r\n```js\r\nfruits.forEach(function(fruit) {\r\n\tconsole.log(fruit); // Apple, Orange, Banna, Mango\r\n})\r\n```\r\n\r\nHàm nằm bên trong forEach là một callback nhận vào tham số `fruit` là giá trị của từng phần tử nằm trong mảng, đây là cách rất đơn giản để ta lặp qua mảng và lấy giá trị của phần tử nằm trong một mảng bất kỳ được cung cấp thông qua dạng [Array].forEach\r\n\r\n## Vị trí của phần tử trong forEach\r\nThông thường, chúng ta chỉ sử dụng tham số thứ nhất để xử lý các trường hợp gặp phải. Nhưng một số trường hợp chúng ta cũng cần đến tham số vị trí của giá trị để khai thác thông tin dữ liệu chính xác. Đây cũng là mục đích để ta tìm hiểu về vị trí của phần tử trong phương thức **forEach**, nó là tham số thứ 2, sau tham số giá trị đầu tiên trong **callback**.\r\n\r\nTa sẽ cùng tìm hiểu cách truy xuất vị trí của các giá trị trong mảng `fruits` qua ví dụ bên dưới\r\n\r\n```js\r\nfruits.forEach(function (fruit, index) {\r\n\tconsole.log(fruit, \"Vị trí \" + index);\r\n\t// \"Apple\" \"Vị trí 0\"\r\n\t// \"Orange\" \"Vị trí 1\"\r\n\t// \"Banner\" \"Vị trí 2\"\r\n\t// \"Mango\" \"Vị trí 3\"\r\n})\r\n```\r\n\r\n## Truy cập mảng gốc bên trong vòng lặp\r\nĐể truy cập vào chính mảng đang được lặp qua, chúng ta sẽ sử dụng tham số thứ 3 bên trong hàm **callback**. Bây giờ hãy cùng thử hiển thị tham số thứ 3 `array` bên trong vòng lặp đang thực thi.\r\n\r\n```js\r\nfruits.forEach(function(fruit, index, array) {\r\n\tconsole.log(array);\r\n\t//  [\"Apple\", \"Orange\", \"Banana\", \"Mango\"] // 4 lần \r\n})\r\n```\r\n\r\nMảng tham số thứ 3 bên trong hàm `callback` là mảng mà phương thức forEach () đã gọi.\r\n\r\n## `This` bên trong callback\r\nHãy chạy ví dụ sau và chú ý hiển thị giá trị của `this` và so với **window global** nhé.\r\n\r\n```js\r\nfruits.forEach(function(fruit, index, array) {\r\n\tconsole.log(this); // window {...}\r\n\tconsole.log(this === window) // true\r\n})\r\n```\r\n\r\n`this` bên trong hàm `callback` bằng **window** (window là một đối tượng toàn cục trong môi trường trình duyệt. \r\n\r\nTrong một số tình huống, bạn sẽ cần truy cập từ khoá `this` ngay bên trong vòng lặp, có thể là một ngữ cảnh khác để tính toán lựa chọn dữ liệu cho bạn. Bằng cách đó, ta có thể chỉ ra đối tượng `this` bằng tham số thứ 2 trong **forEach**:\r\n\r\n```js\r\nfruits.forEach(function() {}, thisArg)\r\n```\r\n\r\nHãy xem ví dụ bên dưới, giả sử mình có ngữ cảnh kho chứa chỉ có mỗi loại trái cây chuối, cần kiểm tra danh sách trái cây nào chưa có trong ngữ cảnh kho sẽ được chuyển vào đó.\r\n\r\n```js\r\n// Kho chứa\r\nlet stored = {\r\n\tstored: [\"Banana\"]\r\n}\r\n\r\n// Danh sách trái cây mới\r\nlet fruits = [\"Apple\", \"Orange\", \"Banana\", \"Mango\"]\r\n\r\n// Lặp qua danh sách trái cây mới\r\nfruits.forEach(function(fruit) {\r\n\t// Kiểm tra xem trái cây mới có tồn tại trong kho chứa, nếu không thì chuyển vào\r\n\tif(!this.stored.includes(fruit)) {\r\n\t\tthis.stored.push(fruit)\r\n\t}\r\n}, stored)\r\n\r\n// Kết quả mong muốn : [\"Banana\", \"Apple\", \"Orange\", \"Mango\"]\r\nconsole.log(stored) // [\"Banana\", \"Apple\", \"Orange\", \"Mango\"]\r\n```\r\n\r\nNgoài ra, đối với ví dụ trên, chúng ta có thể sử dụng **arrow function** làm hàm **callback** của **forEach()** sẽ tốt hơn. Arrow function bảo toàn giá trị của `this` khỏi phạm vi `lexical scope`. Vì vậy không cần sử dụng đến đối số thứ 2 trong **forEach**.\r\n\r\n## forEach bỏ qua giá trị khoảng trống\r\nforEach() khi thực thi sẽ bỏ qua giá trị empty bên trong mảng.\r\n\r\n```js\r\nconst fruits = [\"Apple\", , \"Banana\", \"Mango\"];\r\n\r\nconsole.log(fruits.length) // length = 4;\r\n\r\nfruits.forEach(function(fruit) {\r\n\tconsole.log(fruit);\r\n\t\r\n\t// Hiển thị: \"Apple\", \"Banana\", \"Mango\"\r\n})\r\n```\r\n\r\n## Lặp qua Array-like object bằng forEach\r\nNhư các phương thức `map`, `filter`, `find`, ..etc. Chúng ta không thể lặp qua một **array-like**, chỉ có **forEach** có khả năng làm điều này.\r\n\r\n```js\r\nconst fruits = {\r\n\t\"0\": \"Apple\",\r\n\t\"1\": \"Mango\",\r\n\t\"length\": 2\r\n}\r\n\r\nArray.prototype.forEach.call(fruits, function(fruit) {\r\n\tconsole.log(fruit) // \"Apple\", \"Mango\"\r\n});\r\n```\r\n\r\nNgoài ra bạn cũng có thể lặp qua **NodeList** từ DOM HTML bằng **forEach**\r\n\r\n```js\r\ndocument.querySelectorAll(\"img\").forEach(function(element) {\r\n\tconsole.log(element) // HTMLElement\r\n})\r\n```\r\n\r\n## Kết luận\r\n**forEach()** là một phương thức lặp qua tất cả phần tử trong mảng một cách hiệu quả. Đối số đầu tiên nó là hàm **callback**, gọi cho mọi phần trong mảng với 3 đối số `item`, `index`, `array`.\r\n\r\n**forEach()** là phương thức rất hữu ích để lặp qua tất cả giá trị trong mảng mà không làm phá vỡ cấu trúc mảng ban đầu.","userId":2,"status":1,"created_at":"2021-02-03T19:09:52.000000Z","updated_at":"2022-03-31T08:40:02.000000Z","publish_at":"2021-02-04 02:09:52"},{"postId":14,"title":"Hướng dẫn sử dụng useCallback trong React","views":11112,"thumbnail":"https://codestus.com/uploads/images/posts/3b9b3cd5-5376-4f5f-aa41-57dc9d46e045.png","slug":"huong-dan-su-dung-usecallback-trong-react","description":"React hooks là một phương thức quản lý state mới trong function components, được giới thiệu trong phiên bản React v16.8","content":"**React hooks** là một phương thức quản lý state mới trong function components, được giới thiệu trong phiên bản **React v16.8**. Với những hook như **useState**, **useEffect** và một số khác. Các nhà phát triển cuối cùng có thể làm việc với các **side effects** trong các thành phần chức năng.\r\n\r\nTrong bài viết lần này, chúng ta sẽ xem xét về **useCallback**, một trong những **hook** được giới thiệu từ bản cập nhật của **React**, và tìm hiểu xem làm thế nào để chúng ta sử dụng **useCallback** tốt.\r\n\r\n## Giới thiệu sơ về `useCallback`\r\n`useCallback` là được sử dụng để tối ưu quá trình **render** của **React functional components**. Nó sẽ rất hữu ích đối với trường hợp một thành phần (component) liên tục được hiển thị lại không cần thiết trong quá trình xử lý sự kiện người dùng và có hành vi chức năng phức tạp. Chúng ta sẽ xem xét thông qua ví dụ đơn giản về cách triển khai hook này để xem cách nó có thể giúp chúng ta đạt hiệu quả thế nào trong quá trình xử lý **re-rendering** của **component**.\r\n\r\nHãy nhớ rằng **React** đã rất nhanh, tối ưu hiệu xuất chỉ nên sử dụng cho những component có khả năng chậm, xử lý tác vụ nặng. Khi đó, chúng ta sẽ xem xét xử dụng `useCallback` làm một phần hỗ trợ tối ưu hiện xuất trong các hook.\r\n\r\nNào, bây giờ hãy xem xét ví dụ đơn giản qua `Counter` Component nhé:\r\n\r\n```jsx\r\nimport React, { useState, useCallback } from 'react'\r\n\r\nfunction Counter() {\r\n\tconst [count, setCount] = useState(0);\r\n\tconst [countOther, setCountOther] = useState(0);\r\n\t\r\n\tconst increase = () =\u003e setCount(count + 1);\r\n\tconst decrease = () =\u003e setCount(count - 1);\r\n\t\r\n\tconst increaseOther = () =\u003e setCountOther(countOther + 1);\r\n\tconst decreaseOther = () =\u003e setCountOther(countOther + 1);\r\n\t\r\n\treturn (\r\n\t\t\t\u003c\u003e\r\n\t\t\t\t\u003cdiv\u003eCount: {count}\u003c/div\u003e\r\n\t\t\t\t\u003cbutton onClick={increase}\u003e+\u003c/button\u003e\r\n\t\t\t\t\u003cbutton onClick={increase}\u003e-\u003c/button\u003e\r\n\r\n\t\t\t\t\u003cdiv\u003eCount other: {countOther}\u003c/div\u003e\r\n\t\t\t\t\u003cbutton onClick={increaseOther}\u003e+\u003c/button\u003e\r\n\t\t\t\t\u003cbutton onClick={decreaseOther}\u003e-\u003c/button\u003e\r\n\t\t\t\u003c/\u003e\r\n\t)\r\n}\r\n\r\nexport default Counter;\r\n```\r\n\r\nĐiều này khá đơn giản, chúng ta có biến **2 state** nắm giữ số đếm và 4 hàm để thay đổi con số của 2 state trên.\r\nTuy nhiên, vấn đề ở đây là mỗi lần thành phần `Counter` này re-render, tất cả 4 hàm, `increase`, `decrease`, `increaseOther`, `decreaseOther` sẽ bị khởi tạo lại.\r\n\r\nChúng ta có thể thấy điều đó bằng cách sử dụng `Set` và thêm các hàm vào bên trong `Set` mỗi lần `Counter` re-render. Tại sao lại là `Set`. Đây là đối tượng lưu trữ phần tử có tính duy nhất, không trùng lặp.\r\n\r\n```jsx\r\nimport React, { useState, useCallback } from 'react'\r\n\r\nconst storeSet = new Set(); \r\n\r\nfunction Counter() {\r\n\tconst [count, setCount] = useState(0);\r\n\tconst [countOther, setCountOther] = useState(0);\r\n\t\r\n\tconst increase = () =\u003e setCount(count + 1);\r\n\tconst decrease = () =\u003e setCount(count - 1);\r\n\t\r\n\tconst increaseOther = () =\u003e setCountOther(countOther + 1);\r\n\tconst decreaseOther = () =\u003e setCountOther(countOther + 1);\r\n\t\r\n\tstoreSet.add(increase);\r\n\tstoreSet.add(decrease);\r\n\tstoreSet.add(increaseOther);\r\n\tstoreSet.add(decreaseOther);\r\n\t\r\n\tconsole.log(storeSet);\r\n\t\r\n\treturn (\r\n\t\t\t\u003c\u003e\r\n\t\t\t\t\u003cdiv\u003eCount: {count}\u003c/div\u003e\r\n\t\t\t\t\u003cbutton onClick={increase}\u003e+\u003c/button\u003e\r\n\t\t\t\t\u003cbutton onClick={increase}\u003e-\u003c/button\u003e\r\n\r\n\t\t\t\t\u003cdiv\u003eCount other: {countOther}\u003c/div\u003e\r\n\t\t\t\t\u003cbutton onClick={increaseOther}\u003e+\u003c/button\u003e\r\n\t\t\t\t\u003cbutton onClick={decreaseOther}\u003e-\u003c/button\u003e\r\n\t\t\t\u003c/\u003e\r\n\t)\r\n}\r\n\r\nexport default Counter;\r\n```\r\n\r\nNào, bây giờ cùng kiểm tra thử nhé?. Mỗi lần bạn **click** vào bất kì nút tăng giảm sẽ thấy hiển thị giá trị của `storeSet`. Bạn sẽ thấy chúng tăng giá trị mỗi lần hiển thị, điều này cho thấy mỗi lần thành phần `re-render` sẽ tạo ra phiên bản hoàn toàn mới của các hạm được tạo ra.\r\n\r\nVề cốt lõi, vấn đề này là do cách `JavaScript` xác định bình đẳng hàm.\r\n\r\n## Function Equality trong Javascript\r\n\r\nHãy xem ví dụ bên dưới trong đó chúng ta có hàm `factory` đang trả về một hàm khác.\r\n\r\n```js\r\nfunction factory() {\r\n\treturn (a,b) =\u003e a + b;\r\n}\r\n\r\nconst functionA = factory();\r\nconst functionB = factory();\r\n\r\nfunctionA(1,2); // 3\r\nfunctionB(1,2); // 3\r\n\r\nconsole.log(functionA === functionB) // false\r\nconsole.log(functionA === functionA) // true\r\n```\r\n\r\nTại đây, chúng ta tạo ra `functionA` và `functionB` thông qua `factory()`. Bạn có thể tìm hiểu thêm về hàm trong JavaScript thông qua [First-class Function](https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function), nghĩa là chúng được thể hiện dưới dạng các đối tượng thông thường. Đối tượng hàm có thể trả về một hàm khác (giống như hàm `factory`).\r\n\r\nBạn có thể thấy rằng, mặc dù `functionA` và `functionB` đều đến từ cùng một hàm `factory` và cùng làm một việc. chúng vốn dĩ là các đối tượng khác nhau, vì vậy, chúng không thể bằng nhau. Bất kì hàm JavaScript nào chỉ có thể bằng chính nó.\r\n\r\nBây giờ cùng trở lại với **React**, khi một thành phần `re-render`, mọi hàm bên trong nó sẽ bị `recreated`. `useCallback` làm cho nó có thể được `memoize` lại (hay là **cache**) **instance** hàm giữa những lần `render`. Điều này có ý nghĩa thay vì tạo lại đối tượng hàm mới, chúng ta có thể sử dụng lại cùng một đối tượng giữa các lần hiển thị.\r\n\r\nHãy cùng cập nhật cho các hàm increase/decrease sử dụng `useCallback`\r\n\r\n```jsx\r\nconst increase = useCallback(() =\u003e setCount(count + 1), [count]);\r\nconst decrease = useCallback(() =\u003e setCount(count - 1), [count]);\r\n\t\r\nconst increaseOther = useCallback(() =\u003e setCountOther(countOther + 1), [countOther]);\r\nconst decreaseOther = useCallback(() =\u003e setCountOther(countOther + 1), [countOther]);\r\n```\r\n\r\nLưu ý, cách chúng ta sử dụng tham số bên trong mảng, phụ thuộc vào một trong các tham số bên trong hàm `useCallback`. Miễn là các giá trị trong mảng phụ thuộc giống nhau giữa các lần hiển thị, **React** sẽ tiếp tục sử dụng phiên bản được `memoized` (cached) của hàm. Nếu các giá trị bên trong mảng phụ thuộc, thay đổi giữa các lần hiển thị, React sẽ tạo lại hàm.\r\n\r\nTrong trường hợp này, khi chúng ta thử ấn button `increase` phía trên sau khi bọc các hàm setState lại bằng `useCallback` ,  kiểm tra hiển thị giá trị của `storeSet` chúng ta chỉ thấy duy nhất có một giá trị được tăng thêm, tiếp tục ấn button `increase` chúng ta vẫn không thấy giá trị thay đổi. \r\n\r\nMặc dù đây là một ví dụ rất đơn giản, nhưng chúng ta có thể thấy cách sử dụng `useCallback` để tối ưu hóa các thành phần có các chức năng phức tạp hoặc tốn nhiều tài nguyên.\r\n\r\n## Khi nào không nên sử dụng `useCallback`\r\nTuy nhiên, hãy đảm bảo rằng điều này không đi quá đà. `useCallback` cũng sỡ hữu nhược điểm,, chủ yếu là độ phức tạp của mã. Ở đây có rất nhiều trường hợp không hợp lý khi thêm `useCallback` và chúng ta phải chấp nhận để hàm khởi tạo lại. Như đã nói, `useCallback` cũng sở hữu nhược điểm về hiệu xuất, vì nó vẫn phải chạy trên mọi thành phần `render`.\r\n\r\nTrong ví dụ này, `useCallback` thực chất sẽ không giúp tối ưu, vì chúng ta tạo đang tạo xử lý `handleClick` cho cả quá trình render của thành phần khác.\r\n\r\n```jsx\r\n\r\nconst ComponentA = () =\u003e {\r\n\tconst [count, setCount] = useState(0)\r\n\tconst handleClick = useCallback(() =\u003e setCount(count + 1), [count]);\r\n\t\r\n\treturn \u003cButtonWrap onClick={handleClick} /\u003e\r\n}\r\n\r\nconst ButtonWrap = ({children, ...props}) =\u003e {\r\n\treturn \u003cbutton {...props}\u003eButton Children\u003c/button\u003e\r\n}\r\n\r\n```\r\n\r\nTrong trường hợp này, `useCallback` sẽ không phát huy được nhiều tác dụng của nó.\r\n\r\nKhi nghĩ về các nâng cấp hiệu xuất như sử dụng `useCallback`, luôn phải đo lường tốc độ của các thành phần component của bạn trước khi bắt đầu tối ưu hoá chúng. Việc tối ưu hoá không cần thiết sẽ khiến code của bạn trở nên rườm rà, phức tạp và có thể khó bảo trì về sau.\r\n\r\n## Kết luận\r\n`useCallback`  là một `react hook` mạnh mã để tối ưu hoá **React component** phức tạp bởi vì chúng sẽ lưu trữ lại các hàm giữa những lần render.\r\n\r\nTrước khi làm việc với `useCallback`, đảm bảo bạn đã phân tích những điều sau:\r\n- Tốc độ tăng có đảm bảo độ phức tạo của vẫn giữ được ở mức cần thiết ?\r\n- Sử dụng `useCallback` có đảm bảo tăng tốc độ cho thành phần được sử dụng?","userId":2,"status":1,"created_at":"2021-02-13T17:09:29.000000Z","updated_at":"2022-03-31T08:30:02.000000Z","publish_at":"2021-02-14 00:09:29"},{"postId":14,"title":"Hướng dẫn sử dụng useCallback trong React","views":11112,"thumbnail":"https://codestus.com/uploads/images/posts/3b9b3cd5-5376-4f5f-aa41-57dc9d46e045.png","slug":"huong-dan-su-dung-usecallback-trong-react","description":"React hooks là một phương thức quản lý state mới trong function components, được giới thiệu trong phiên bản React v16.8","content":"**React hooks** là một phương thức quản lý state mới trong function components, được giới thiệu trong phiên bản **React v16.8**. Với những hook như **useState**, **useEffect** và một số khác. Các nhà phát triển cuối cùng có thể làm việc với các **side effects** trong các thành phần chức năng.\r\n\r\nTrong bài viết lần này, chúng ta sẽ xem xét về **useCallback**, một trong những **hook** được giới thiệu từ bản cập nhật của **React**, và tìm hiểu xem làm thế nào để chúng ta sử dụng **useCallback** tốt.\r\n\r\n## Giới thiệu sơ về `useCallback`\r\n`useCallback` là được sử dụng để tối ưu quá trình **render** của **React functional components**. Nó sẽ rất hữu ích đối với trường hợp một thành phần (component) liên tục được hiển thị lại không cần thiết trong quá trình xử lý sự kiện người dùng và có hành vi chức năng phức tạp. Chúng ta sẽ xem xét thông qua ví dụ đơn giản về cách triển khai hook này để xem cách nó có thể giúp chúng ta đạt hiệu quả thế nào trong quá trình xử lý **re-rendering** của **component**.\r\n\r\nHãy nhớ rằng **React** đã rất nhanh, tối ưu hiệu xuất chỉ nên sử dụng cho những component có khả năng chậm, xử lý tác vụ nặng. Khi đó, chúng ta sẽ xem xét xử dụng `useCallback` làm một phần hỗ trợ tối ưu hiện xuất trong các hook.\r\n\r\nNào, bây giờ hãy xem xét ví dụ đơn giản qua `Counter` Component nhé:\r\n\r\n```jsx\r\nimport React, { useState, useCallback } from 'react'\r\n\r\nfunction Counter() {\r\n\tconst [count, setCount] = useState(0);\r\n\tconst [countOther, setCountOther] = useState(0);\r\n\t\r\n\tconst increase = () =\u003e setCount(count + 1);\r\n\tconst decrease = () =\u003e setCount(count - 1);\r\n\t\r\n\tconst increaseOther = () =\u003e setCountOther(countOther + 1);\r\n\tconst decreaseOther = () =\u003e setCountOther(countOther + 1);\r\n\t\r\n\treturn (\r\n\t\t\t\u003c\u003e\r\n\t\t\t\t\u003cdiv\u003eCount: {count}\u003c/div\u003e\r\n\t\t\t\t\u003cbutton onClick={increase}\u003e+\u003c/button\u003e\r\n\t\t\t\t\u003cbutton onClick={increase}\u003e-\u003c/button\u003e\r\n\r\n\t\t\t\t\u003cdiv\u003eCount other: {countOther}\u003c/div\u003e\r\n\t\t\t\t\u003cbutton onClick={increaseOther}\u003e+\u003c/button\u003e\r\n\t\t\t\t\u003cbutton onClick={decreaseOther}\u003e-\u003c/button\u003e\r\n\t\t\t\u003c/\u003e\r\n\t)\r\n}\r\n\r\nexport default Counter;\r\n```\r\n\r\nĐiều này khá đơn giản, chúng ta có biến **2 state** nắm giữ số đếm và 4 hàm để thay đổi con số của 2 state trên.\r\nTuy nhiên, vấn đề ở đây là mỗi lần thành phần `Counter` này re-render, tất cả 4 hàm, `increase`, `decrease`, `increaseOther`, `decreaseOther` sẽ bị khởi tạo lại.\r\n\r\nChúng ta có thể thấy điều đó bằng cách sử dụng `Set` và thêm các hàm vào bên trong `Set` mỗi lần `Counter` re-render. Tại sao lại là `Set`. Đây là đối tượng lưu trữ phần tử có tính duy nhất, không trùng lặp.\r\n\r\n```jsx\r\nimport React, { useState, useCallback } from 'react'\r\n\r\nconst storeSet = new Set(); \r\n\r\nfunction Counter() {\r\n\tconst [count, setCount] = useState(0);\r\n\tconst [countOther, setCountOther] = useState(0);\r\n\t\r\n\tconst increase = () =\u003e setCount(count + 1);\r\n\tconst decrease = () =\u003e setCount(count - 1);\r\n\t\r\n\tconst increaseOther = () =\u003e setCountOther(countOther + 1);\r\n\tconst decreaseOther = () =\u003e setCountOther(countOther + 1);\r\n\t\r\n\tstoreSet.add(increase);\r\n\tstoreSet.add(decrease);\r\n\tstoreSet.add(increaseOther);\r\n\tstoreSet.add(decreaseOther);\r\n\t\r\n\tconsole.log(storeSet);\r\n\t\r\n\treturn (\r\n\t\t\t\u003c\u003e\r\n\t\t\t\t\u003cdiv\u003eCount: {count}\u003c/div\u003e\r\n\t\t\t\t\u003cbutton onClick={increase}\u003e+\u003c/button\u003e\r\n\t\t\t\t\u003cbutton onClick={increase}\u003e-\u003c/button\u003e\r\n\r\n\t\t\t\t\u003cdiv\u003eCount other: {countOther}\u003c/div\u003e\r\n\t\t\t\t\u003cbutton onClick={increaseOther}\u003e+\u003c/button\u003e\r\n\t\t\t\t\u003cbutton onClick={decreaseOther}\u003e-\u003c/button\u003e\r\n\t\t\t\u003c/\u003e\r\n\t)\r\n}\r\n\r\nexport default Counter;\r\n```\r\n\r\nNào, bây giờ cùng kiểm tra thử nhé?. Mỗi lần bạn **click** vào bất kì nút tăng giảm sẽ thấy hiển thị giá trị của `storeSet`. Bạn sẽ thấy chúng tăng giá trị mỗi lần hiển thị, điều này cho thấy mỗi lần thành phần `re-render` sẽ tạo ra phiên bản hoàn toàn mới của các hạm được tạo ra.\r\n\r\nVề cốt lõi, vấn đề này là do cách `JavaScript` xác định bình đẳng hàm.\r\n\r\n## Function Equality trong Javascript\r\n\r\nHãy xem ví dụ bên dưới trong đó chúng ta có hàm `factory` đang trả về một hàm khác.\r\n\r\n```js\r\nfunction factory() {\r\n\treturn (a,b) =\u003e a + b;\r\n}\r\n\r\nconst functionA = factory();\r\nconst functionB = factory();\r\n\r\nfunctionA(1,2); // 3\r\nfunctionB(1,2); // 3\r\n\r\nconsole.log(functionA === functionB) // false\r\nconsole.log(functionA === functionA) // true\r\n```\r\n\r\nTại đây, chúng ta tạo ra `functionA` và `functionB` thông qua `factory()`. Bạn có thể tìm hiểu thêm về hàm trong JavaScript thông qua [First-class Function](https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function), nghĩa là chúng được thể hiện dưới dạng các đối tượng thông thường. Đối tượng hàm có thể trả về một hàm khác (giống như hàm `factory`).\r\n\r\nBạn có thể thấy rằng, mặc dù `functionA` và `functionB` đều đến từ cùng một hàm `factory` và cùng làm một việc. chúng vốn dĩ là các đối tượng khác nhau, vì vậy, chúng không thể bằng nhau. Bất kì hàm JavaScript nào chỉ có thể bằng chính nó.\r\n\r\nBây giờ cùng trở lại với **React**, khi một thành phần `re-render`, mọi hàm bên trong nó sẽ bị `recreated`. `useCallback` làm cho nó có thể được `memoize` lại (hay là **cache**) **instance** hàm giữa những lần `render`. Điều này có ý nghĩa thay vì tạo lại đối tượng hàm mới, chúng ta có thể sử dụng lại cùng một đối tượng giữa các lần hiển thị.\r\n\r\nHãy cùng cập nhật cho các hàm increase/decrease sử dụng `useCallback`\r\n\r\n```jsx\r\nconst increase = useCallback(() =\u003e setCount(count + 1), [count]);\r\nconst decrease = useCallback(() =\u003e setCount(count - 1), [count]);\r\n\t\r\nconst increaseOther = useCallback(() =\u003e setCountOther(countOther + 1), [countOther]);\r\nconst decreaseOther = useCallback(() =\u003e setCountOther(countOther + 1), [countOther]);\r\n```\r\n\r\nLưu ý, cách chúng ta sử dụng tham số bên trong mảng, phụ thuộc vào một trong các tham số bên trong hàm `useCallback`. Miễn là các giá trị trong mảng phụ thuộc giống nhau giữa các lần hiển thị, **React** sẽ tiếp tục sử dụng phiên bản được `memoized` (cached) của hàm. Nếu các giá trị bên trong mảng phụ thuộc, thay đổi giữa các lần hiển thị, React sẽ tạo lại hàm.\r\n\r\nTrong trường hợp này, khi chúng ta thử ấn button `increase` phía trên sau khi bọc các hàm setState lại bằng `useCallback` ,  kiểm tra hiển thị giá trị của `storeSet` chúng ta chỉ thấy duy nhất có một giá trị được tăng thêm, tiếp tục ấn button `increase` chúng ta vẫn không thấy giá trị thay đổi. \r\n\r\nMặc dù đây là một ví dụ rất đơn giản, nhưng chúng ta có thể thấy cách sử dụng `useCallback` để tối ưu hóa các thành phần có các chức năng phức tạp hoặc tốn nhiều tài nguyên.\r\n\r\n## Khi nào không nên sử dụng `useCallback`\r\nTuy nhiên, hãy đảm bảo rằng điều này không đi quá đà. `useCallback` cũng sỡ hữu nhược điểm,, chủ yếu là độ phức tạp của mã. Ở đây có rất nhiều trường hợp không hợp lý khi thêm `useCallback` và chúng ta phải chấp nhận để hàm khởi tạo lại. Như đã nói, `useCallback` cũng sở hữu nhược điểm về hiệu xuất, vì nó vẫn phải chạy trên mọi thành phần `render`.\r\n\r\nTrong ví dụ này, `useCallback` thực chất sẽ không giúp tối ưu, vì chúng ta tạo đang tạo xử lý `handleClick` cho cả quá trình render của thành phần khác.\r\n\r\n```jsx\r\n\r\nconst ComponentA = () =\u003e {\r\n\tconst [count, setCount] = useState(0)\r\n\tconst handleClick = useCallback(() =\u003e setCount(count + 1), [count]);\r\n\t\r\n\treturn \u003cButtonWrap onClick={handleClick} /\u003e\r\n}\r\n\r\nconst ButtonWrap = ({children, ...props}) =\u003e {\r\n\treturn \u003cbutton {...props}\u003eButton Children\u003c/button\u003e\r\n}\r\n\r\n```\r\n\r\nTrong trường hợp này, `useCallback` sẽ không phát huy được nhiều tác dụng của nó.\r\n\r\nKhi nghĩ về các nâng cấp hiệu xuất như sử dụng `useCallback`, luôn phải đo lường tốc độ của các thành phần component của bạn trước khi bắt đầu tối ưu hoá chúng. Việc tối ưu hoá không cần thiết sẽ khiến code của bạn trở nên rườm rà, phức tạp và có thể khó bảo trì về sau.\r\n\r\n## Kết luận\r\n`useCallback`  là một `react hook` mạnh mã để tối ưu hoá **React component** phức tạp bởi vì chúng sẽ lưu trữ lại các hàm giữa những lần render.\r\n\r\nTrước khi làm việc với `useCallback`, đảm bảo bạn đã phân tích những điều sau:\r\n- Tốc độ tăng có đảm bảo độ phức tạo của vẫn giữ được ở mức cần thiết ?\r\n- Sử dụng `useCallback` có đảm bảo tăng tốc độ cho thành phần được sử dụng?","userId":2,"status":1,"created_at":"2021-02-13T17:09:29.000000Z","updated_at":"2022-03-31T08:30:02.000000Z","publish_at":"2021-02-14 00:09:29"},{"postId":17,"title":"Xây dựng UI Component Design Systems dành cho lập trình viên Frontend (Phần 2)","views":1654,"thumbnail":"https://codestus.com/uploads/images/users/duongductrong/161613794534preview.png","slug":"xay-dung-ui-component-design-systems-danh-cho-lap-trinh-vien-frontend-phan-2","description":"Có 2 cách để chúng ta thiết kế, xây dựng hệ thống. Lựa chọn phù hợp chủ yếu dựa trên việc bạn là ai và bạn cần đạt được những gì.","content":"Trong [phần trước](https://codestus.com/posts/xay-dung-ui-component-design-systems-danh-cho-lap-trinh-vien-frontend) chúng ta đã tìm hiểu về các phần:\r\n- **Thu hẹp khoảng các giữa nhà phát triển và thiết kế**\r\n- **Chọn stack và tools**\r\nChỉ ra những lựa chọn, luồng xử lý, công nghệ sử dụng để xây dựng hệ thống UI Component.\r\n\r\nTrong phần này, chúng ta sẽ tiến sâu hơn một chút về cách thiết kế, xây dựng hệ thống.\r\n\r\n## Thiết kế, Xây dựng hệ thống giao diện thành phần\r\nCó 2 cách để chúng ta thiết kế, xây dựng hệ thống. Lựa chọn phù hợp chủ yếu dựa trên việc bạn là ai và bạn cần đạt được những gì.\r\n\r\n### Thiết kế trước, sau đó xây dựng các thành phần có khả năng tái sử dụng (reusable)\r\nMột tiêu chuẩn được sử dụng rộng rãi ở hầu hết các tổ chức trong quá trình xây dựng UX/UI và phát triển qua nhiều nhóm và sản phẩm, đó là **Design Components First** và hãy đảm bảo rằng bản thiết kế này được thực hiện như việc phát triển các thành phần (components) và được sử dụng ở mọi nơi.\r\n\r\nNào, hãy cùng xem luồng làm việc này thông qua một cấu trúc đơn giản như sau:\r\n- Xây dựng ngôn ngữ hình ảnh và thiết kế thành phần\r\n- Thực hiện phát triển các thành phần trong các môi trường quản lý codebase như github/gitlab.\r\n- Sử dụng các **components-platform** để quản lý các **package** được phát triển từ hệ thống\r\n- Chuẩn hoá các phiên bản của thành phần qua các dự án và ứng dụng.\r\n- Theo dõi, cập nhật và phát triển các thành phần\r\n\r\n### Design Systems và Atomic Design\r\nThông qua việc so sánh các thành phần với các nguyên tử, phân tử, chúng ta có thể nghĩ rằng thiết kế giao diện người dùng của chúng ta như một thành phần của các mô-đun được ghép lại với nhau.\r\n\r\nAtomic design sẽ giúp [bạn phát triển và duy trì hệ thống một cách mạnh mẽ](https://bradfrost.com/blog/post/atomic-web-design/). Cho phép phát triển với chất lượng cao hơn, giao diện người dùng nhất quán hơn...\r\n\r\n## Kết hợp quản lý và cập nhật các thành phần\r\nTheo thời gian, hệ thống giao diện thành phần của bạn sẽ có một số phát sinh cần phải thay đổi như môi trường, màu sắc...Thiết kế có thể thay đổi, và các thành phần cũng vậy\r\n\r\nCác thành phần có thể thay đổi để phù hợp với các sản phẩm mới và thiết kế cũng vậy. Vì vậy, bạn phải coi quy trình này là sự kết hợp 2 chiều.\r\n\r\n### Kiểm soát các thay đổi thành phần trong các dự án\r\nKhi một thành phần được sử dụng trong 2 hoặc nhiều dự án, sớm muộn bạn sẽ phải thay đổi nó để phù hợp hơn với các dự án. Vì vậy, bạn có thể phải cập nhật một thành phần từ dự án này sang dự án khác. Kết hợp các thay đổi mã nguồn và cập nhật đầy đủ các phụ thuộc ảnh hưởng đến sự thay đổi của thành phần.\r\n\r\n## Phát triển một hệ sinh thái các thành phần trong tổ chức của bạn.\r\n![Phát triển hệ sinh thái các thành phần trong tổ chức](https://res.cloudinary.com/practicaldev/image/fetch/s--I1BQQEIe--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/kwqc7cp1n1mxykxkbndh.png)\r\n\r\nXây dựng hệ thống thiết kế thực sự là xây dựng một hệ sinh thái thành phần đang phát triển trong tổ chức của bạn. Điều này có nghĩa là việc quản lý các thành phần không phải là con đường một chiều, bao gồm những người xây dựng ứng dụng (người tiêu dùng thành phần) để các thành phần bạn xây dựng sẽ thực sự được sử dụng chúng trong các ứng dụng và sản phẩm của họ.\r\n\r\nChia sẻ các thành phần đến nơi mà mọi người có thể dễ dàng tìm thấy và sử dụng. Hãy để họ cộng tác và làm cho việc đó trở nên dễ dàng và thú vị. Đừng ép các nhà phát triển cài đặt các thư viện nặng hoặc tham gia quá sâu vào thư viện của bạn chỉ để thực hiện một yêu cầu nhỏ. Đừng làm khó các nhà thiết kế khi tìm hiểu chính xác những thành phần nào thay đổi theo thời gian và giúp họ dễ dàng cộng tác trong quá trình này.\r\n\r\nHãy xem hệ thống thiết kế thành phần của bạn là một sinh vật sống và thở, phát triển  theo thời gian. Nếu bạn cố gắng thực thi nó trên tổ chức của mình, nó có thể chết. Thay vào đó, hãy phát triển nó thích hợp với nhiều môi trường. Điều chỉnh quy trình này để đạt được tiêu chuẩn hóa, nhưng không cản trở hoặc làm suy yếu việc áp dụng- bằng mọi giá. BIT có lẽ là công cụ quyền lực nổi bật nhất ở đây, nhưng hãy chia sẻ nhiều hơn nếu bạn biết chúng.\r\n\r\n## Kết luận\r\nHệ thống thiết kế giúp tạo ra sự nhất quán trong trải nghiệm hình ảnh và chức năng mà bạn cung cấp cho người dùng, đồng thời hình thành thương hiệu của bạn trên các sản phẩm và ứng dụng khác nhau. Các thành phần, có hoặc không có sử dụng framework, cho phép bạn triển khai hệ thống này như một tập hợp các khối xây dựng sống động có thể và nên được chia sẻ giữa các dự án để chuẩn hóa và tăng tốc độ phát triển.","userId":2,"status":1,"created_at":"2021-02-19T08:17:03.000000Z","updated_at":"2022-03-31T08:00:02.000000Z","publish_at":"2021-02-19 15:17:03"},{"postId":17,"title":"Xây dựng UI Component Design Systems dành cho lập trình viên Frontend (Phần 2)","views":1654,"thumbnail":"https://codestus.com/uploads/images/users/duongductrong/161613794534preview.png","slug":"xay-dung-ui-component-design-systems-danh-cho-lap-trinh-vien-frontend-phan-2","description":"Có 2 cách để chúng ta thiết kế, xây dựng hệ thống. Lựa chọn phù hợp chủ yếu dựa trên việc bạn là ai và bạn cần đạt được những gì.","content":"Trong [phần trước](https://codestus.com/posts/xay-dung-ui-component-design-systems-danh-cho-lap-trinh-vien-frontend) chúng ta đã tìm hiểu về các phần:\r\n- **Thu hẹp khoảng các giữa nhà phát triển và thiết kế**\r\n- **Chọn stack và tools**\r\nChỉ ra những lựa chọn, luồng xử lý, công nghệ sử dụng để xây dựng hệ thống UI Component.\r\n\r\nTrong phần này, chúng ta sẽ tiến sâu hơn một chút về cách thiết kế, xây dựng hệ thống.\r\n\r\n## Thiết kế, Xây dựng hệ thống giao diện thành phần\r\nCó 2 cách để chúng ta thiết kế, xây dựng hệ thống. Lựa chọn phù hợp chủ yếu dựa trên việc bạn là ai và bạn cần đạt được những gì.\r\n\r\n### Thiết kế trước, sau đó xây dựng các thành phần có khả năng tái sử dụng (reusable)\r\nMột tiêu chuẩn được sử dụng rộng rãi ở hầu hết các tổ chức trong quá trình xây dựng UX/UI và phát triển qua nhiều nhóm và sản phẩm, đó là **Design Components First** và hãy đảm bảo rằng bản thiết kế này được thực hiện như việc phát triển các thành phần (components) và được sử dụng ở mọi nơi.\r\n\r\nNào, hãy cùng xem luồng làm việc này thông qua một cấu trúc đơn giản như sau:\r\n- Xây dựng ngôn ngữ hình ảnh và thiết kế thành phần\r\n- Thực hiện phát triển các thành phần trong các môi trường quản lý codebase như github/gitlab.\r\n- Sử dụng các **components-platform** để quản lý các **package** được phát triển từ hệ thống\r\n- Chuẩn hoá các phiên bản của thành phần qua các dự án và ứng dụng.\r\n- Theo dõi, cập nhật và phát triển các thành phần\r\n\r\n### Design Systems và Atomic Design\r\nThông qua việc so sánh các thành phần với các nguyên tử, phân tử, chúng ta có thể nghĩ rằng thiết kế giao diện người dùng của chúng ta như một thành phần của các mô-đun được ghép lại với nhau.\r\n\r\nAtomic design sẽ giúp [bạn phát triển và duy trì hệ thống một cách mạnh mẽ](https://bradfrost.com/blog/post/atomic-web-design/). Cho phép phát triển với chất lượng cao hơn, giao diện người dùng nhất quán hơn...\r\n\r\n## Kết hợp quản lý và cập nhật các thành phần\r\nTheo thời gian, hệ thống giao diện thành phần của bạn sẽ có một số phát sinh cần phải thay đổi như môi trường, màu sắc...Thiết kế có thể thay đổi, và các thành phần cũng vậy\r\n\r\nCác thành phần có thể thay đổi để phù hợp với các sản phẩm mới và thiết kế cũng vậy. Vì vậy, bạn phải coi quy trình này là sự kết hợp 2 chiều.\r\n\r\n### Kiểm soát các thay đổi thành phần trong các dự án\r\nKhi một thành phần được sử dụng trong 2 hoặc nhiều dự án, sớm muộn bạn sẽ phải thay đổi nó để phù hợp hơn với các dự án. Vì vậy, bạn có thể phải cập nhật một thành phần từ dự án này sang dự án khác. Kết hợp các thay đổi mã nguồn và cập nhật đầy đủ các phụ thuộc ảnh hưởng đến sự thay đổi của thành phần.\r\n\r\n## Phát triển một hệ sinh thái các thành phần trong tổ chức của bạn.\r\n![Phát triển hệ sinh thái các thành phần trong tổ chức](https://res.cloudinary.com/practicaldev/image/fetch/s--I1BQQEIe--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/kwqc7cp1n1mxykxkbndh.png)\r\n\r\nXây dựng hệ thống thiết kế thực sự là xây dựng một hệ sinh thái thành phần đang phát triển trong tổ chức của bạn. Điều này có nghĩa là việc quản lý các thành phần không phải là con đường một chiều, bao gồm những người xây dựng ứng dụng (người tiêu dùng thành phần) để các thành phần bạn xây dựng sẽ thực sự được sử dụng chúng trong các ứng dụng và sản phẩm của họ.\r\n\r\nChia sẻ các thành phần đến nơi mà mọi người có thể dễ dàng tìm thấy và sử dụng. Hãy để họ cộng tác và làm cho việc đó trở nên dễ dàng và thú vị. Đừng ép các nhà phát triển cài đặt các thư viện nặng hoặc tham gia quá sâu vào thư viện của bạn chỉ để thực hiện một yêu cầu nhỏ. Đừng làm khó các nhà thiết kế khi tìm hiểu chính xác những thành phần nào thay đổi theo thời gian và giúp họ dễ dàng cộng tác trong quá trình này.\r\n\r\nHãy xem hệ thống thiết kế thành phần của bạn là một sinh vật sống và thở, phát triển  theo thời gian. Nếu bạn cố gắng thực thi nó trên tổ chức của mình, nó có thể chết. Thay vào đó, hãy phát triển nó thích hợp với nhiều môi trường. Điều chỉnh quy trình này để đạt được tiêu chuẩn hóa, nhưng không cản trở hoặc làm suy yếu việc áp dụng- bằng mọi giá. BIT có lẽ là công cụ quyền lực nổi bật nhất ở đây, nhưng hãy chia sẻ nhiều hơn nếu bạn biết chúng.\r\n\r\n## Kết luận\r\nHệ thống thiết kế giúp tạo ra sự nhất quán trong trải nghiệm hình ảnh và chức năng mà bạn cung cấp cho người dùng, đồng thời hình thành thương hiệu của bạn trên các sản phẩm và ứng dụng khác nhau. Các thành phần, có hoặc không có sử dụng framework, cho phép bạn triển khai hệ thống này như một tập hợp các khối xây dựng sống động có thể và nên được chia sẻ giữa các dự án để chuẩn hóa và tăng tốc độ phát triển.","userId":2,"status":1,"created_at":"2021-02-19T08:17:03.000000Z","updated_at":"2022-03-31T08:00:02.000000Z","publish_at":"2021-02-19 15:17:03"},{"postId":21,"title":"Promise Memoization Pattern","views":1480,"thumbnail":"https://res.cloudinary.com/xskill/image/upload/v1614513161/codestus/cdjfzffohnksc1x9pmqb.jpg","slug":"promise-memoization-pattern","description":"Nếu bạn đang tìm hiểu về cách triển khai bộ nhớ đệm (caching) cho Promise, thì đây sẽ là một bài viết dành cho bạn.","content":"Nếu bạn đang tìm hiểu về cách triển khai bộ nhớ đệm (caching) cho Promise, thì đây sẽ là một bài viết dành cho bạn. \r\n\r\n## Trường hợp sử dụng: Caching asynchronous results\r\nNó có nghĩa là chúng ta sẽ lưu kết quả bất đồng bộ khi gọi api trả về và lưu chúng vào bộ nhớ đệm.\r\n\r\n```js\r\n// Thực hiện gọi một api để lấy dữ liệu bài viết theo ID\r\nconst getPostById = async (postId) : Promise\u003cPost\u003e =\u003e {\r\n\tconst post = await (await fetch(`/api/v1/posts/${postId}`)).json();\r\n\treturn post;\r\n}\r\n```\r\n\r\nCách này hoàn toàn bình thường. Nhưng, nếu nó ảnh hưởng đến hiểu xuất? Chúng ta nên làm gì với nó. Có thể `api/v1/posts/${postId}` sẽ phải hoạt động rất chậm để lấy được thông tin chi tiết của bài viết. Có thể chúng ta hay thường gọi đến api này để lấy thông tin bài viết như cách bạn đọc bài viết trên codestus.com.\r\n\r\nVì nó có thể được gọi lại nhiều lần, cùng với một id để lấy chi tiết bài viết chúng ta muốn. Có lẽ chúng ta sẽ muốn thêm nó vào bộ nhớ đệm.\r\n\r\n## Cách giải quyết thông thường\r\nĐây là cách giải quyết mà chúng ta thường thấy:\r\n\r\n```js\r\nconst caching = new Map\u003cstring, Post\u003e();\r\n\r\n// Sửa đổi một chút\r\n// Thực hiện gọi một api để lấy dữ liệu bài viết theo ID\r\nconst getPostById = async (postId) : Promise\u003cPost\u003e =\u003e {\r\n\t\r\n\tif(!caching.has(postId)) {\r\n\t\tconst post = await (await fetch(`/api/v1/posts/${postId}`)).json();\r\n\t\t\r\n\t\tcaching.set(postId, post);\r\n\t}\r\n\t\r\n\treturn caching.get(postId);\r\n}\r\n```\r\n\r\n- Chúng ta điền vào bộ nhớ đệm kết quả lấy được từ api chậm chập kia, sau đó phản hồi lại cho người dùng bằng cách `get` chúng từ `caching`.\r\n- Trường hợp đã tồn tại trong `caching`, chúng ta chỉ cần lấy nó từ bộ nhớ ra\r\n\r\nVới cách thức vô cùng đơn giản này, chúng ta giải quyết quyết được vấn đề từ `/api/v1/posts`\r\n\r\nCách làm này còn có một cái tên là **Singleton Promise**. Tương tự như [Design Pattern Singleton](https://codestus.com/posts/6-design-patterns-thong-dung-trong-javascript-can-biet?page_comment=0), nếu gọi cùng một Promise với cùng một id chúng sẽ lấy ra được thông tin của cùng đối tượng chúng ta lưu trong `caching` giống như  Singleton chỉ khai báo và lấy duy nhất một `instance`.\r\n\r\n```js\r\nPromise.all([\r\n\tgetPostById(\"bai-viet-1\"),\r\n\tgetPostById(\"bai-viet-1\"),\r\n]);\r\n```\r\n\r\nNhư trên, chúng ta sẽ không gặp bất cứ vấn đề gì trong quá trình truy vấn.\r\n\r\n## Promise Memoization\r\nNhìn từ một góc độ khác, việc triển khai bộ nhớ đệm này thực sự chỉ là ghi nhớ `getPostById()`. Khi được cung cấp thông tin đầu vào mà chúng ta đã thấy, chúng ta chỉ việc trả lại kết quả mà chúng ta đã lưu trữ từ lần đầu tiên gọi.\r\n\r\nMặt trái của nó là có nhiều thư viện làm cho việc ghi nhớ trở nên đơn giản, bao gồm cả lodash.\r\n\r\nChúng ta có thể đơn giản hóa giải pháp cuối cùng của mình để:\r\n\r\n```js\r\nimport _ from 'lodash';\r\n\r\nconst getPostById = _.memoize(async (postId: string): Promise\u003cPost\u003e =\u003e {\r\n  const post = await ( await fetch(`/api/v1/posts/${postId}`) ).json();\r\n  return post;\r\n});\r\n\r\n```\r\n\r\nChúng ta đã thực hiện nó mà không triển khai bộ nhớ cache ban đầu của mình, thay thế nó bằng các bao bọc _.memoize. Rất đơn giản.\r\n\r\n- [**About Advanced Promise Patterns: Promise Memoization**](https://www.jonmellman.com/posts/promise-memoization)","userId":2,"status":1,"created_at":"2021-02-27T15:52:26.000000Z","updated_at":"2022-03-31T07:40:02.000000Z","publish_at":"2021-02-27 22:52:26"},{"postId":23,"title":"CSS Grid #1: Tìm hiểu về Grid","views":1498,"thumbnail":"https://res.cloudinary.com/xskill/image/upload/v1615177009/codestus/kvdpsoyfvxgehj90iv6h.png","slug":"css-grid-phan-1-tim-hieu-ve-grid","description":"Chúng ta hãy bắt đầu thay suy nghĩ về CSS Grid đi nhé. Đây là Cheatsheet về mọi thứ bạn có thể làm với Grid để bắt đầu vào năm 2021!","content":"Chúng ta hãy bắt đầu thay suy nghĩ về CSS Grid đi nhé. Đây là Cheatsheet về mọi thứ bạn có thể làm với Grid để bắt đầu vào năm 2021!\n\n## Kiến trúc Grid\n![](https://res.cloudinary.com/xskill/image/upload/v1615132845/codestus/pehkfp8bnqk4212phzf7.png)\n\nBên trên là hình ảnh sơ về `grid architecture` hoạt động theo 2  trục `Cross Axis (Rows)` và `Main Axis (Column)`.\n\nGiờ cùng bắt đầu tìm hiểu về `grid` qua các thuộc tính của nó cùng mình nhé.\n\n## Thuộc tính grid-template-column\n![Thuộc tính grid-template-columns](https://res.cloudinary.com/practicaldev/image/fetch/s--SsyA3A3f--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pu3jedhac2u0onuan6go.png)\nDựa theo `grid-template-column` trong ảnh, chúng ta có thể biết được số cột (column) là 3\n- Cột 1: width 200px\n- Cột 2: width `auto`\n- Cột 3: width 100px\n\nChúng ta sử dụng nó để số cột  và độ rộng của mỗi cột theo trục `main axis` như hình phía trên.  Bạn có thể đặt riêng chiều rộng của từng cột hoặc đặt chiều rộng đồng nhất cho tất cả các cột bằng cách sử dụng hàm `repeat ()`.\n![Thuộc tính grid-template-column](https://res.cloudinary.com/xskill/image/upload/v1615135590/codestus/gpqritt3b7rq2go69itn.png)\n\n## Thuộc tính grid-template-rows\nNgược lại với `grid-tempate-columns`, thuộc tính `grid-template-rows` sẽ định nghĩa số hàng và kích thuốc của chúng theo chiều dọc `cross axis`.\n\n![Thuộc tính grid-template-rows](https://res.cloudinary.com/xskill/image/upload/v1615175289/codestus/ar66jksteqiamnpwaqkz.png)\n\u003e Nguồn ảnh: Joy Shaheb\n\n\nPhân tích một chút về hình phái trên, chúng ta có tổng thể 3 hàng dựa trên ảnh `grid-template-rows: 200px auto 100px`.\n- Hàng 1 (Màu đỏ): height 200px\n- Hàng 2 (Màu xanh): height `auto`\n- Hàng 3 (Màu đen): height 100px\n\ngiống như `grid-template-columns` chúng ta cũng có thể sử dụng phương thức `repeat(quantity, frame)` để định nghĩa hàng\n\n```css\n.classname {\n\tgrid-temlate-rows: repeat(3, 200px);\n} \n```\n\n![Thuộc tính grid-template-rows](https://res.cloudinary.com/xskill/image/upload/v1615175613/codestus/bafcmijwdhckhed7gmrz.png)\n\u003e Nguồn ảnh: Joy Shaheb\n\n## Thuộc tính grid-template-areas\nChúng ta sử dụng thuộc tính này để chỉ định lượng không gian mà một ô lưới phải mang theo cột \u0026 hàng trên vùng `wrapper`. Điều này sẽ dễ dàng hơn vì bạn có thể quan sát dc những gì chúng ta đang làm.\n\n![Thuộc tính grid-template-areas](https://res.cloudinary.com/xskill/image/upload/v1615175790/codestus/md347vkhtlbhh5r77rik.png)\n\u003e Nguồn ảnh: Joy Shaheb\n\nDựa vào hình ảnh phía trên, chúng ta có một vài thông tin cần thiết\n- Layout chúng ta muốn xây dựng gồm 12 cột và 12 hàng và gồm 3 khối\n\t- Khối A có 12 cột và 4 hàng\n\t- Khối B có 10 cột và 8 hàng\n\t- Khối C có 2 cột và 8 hàng\n\nTừ phân tích chúng ta sẽ có bản thiết kế\n![Grid template area design](https://res.cloudinary.com/xskill/image/upload/v1615176233/codestus/jqr3zxituiwqmndxaxob.png)\n\u003e Nguồn ảnh: Joy Shaheb\n\nVà giả sử khoảng cách giữa các đối tượng phía trên với nhau là 50px bạn sẽ cần biết tới thuộc tính sau\n\n## Column-gap\n`column-gap` được sử dụng để định nghĩa khoảng các giữa các cột:\n\n![](https://res.cloudinary.com/xskill/image/upload/v1615176369/codestus/c4sqinu2aor44mknwird.png)\n\n\u003e Nguồn ảnh: Joy Shaheb\n\nTương tự, chúng ta cũng có `row-gap`\n\n## row-gap\nThuộc tính này cũng tương tự như `column-gap`, nhưng dùng để định nghĩa cho khoảng cách giữa các hàng.\n![](https://res.cloudinary.com/xskill/image/upload/v1615176446/codestus/iodoqzqwvzwwzakf1oik.png)\n\n\u003e Nguồn ảnh: Joy Shaheb\n\nBài có lẽ đến đây đã hơi dài, mình sẽ cắt ngắn từng phần để các bạn dễ đọc và dễ hiểu.\nTrong phần sau, chúng ta sẽ tìm hiểu về các thuộc tính dùng để căn chỉnh phần tủ bên trong grid nhé.","userId":2,"status":1,"created_at":"2021-03-06T21:00:54.000000Z","updated_at":"2022-03-31T07:40:02.000000Z","publish_at":"2021-03-07 04:00:54"},{"postId":24,"title":"Các kỹ thuật viết code javascript mà bạn không thể không biết","views":1292,"thumbnail":"https://res.cloudinary.com/xskill/image/upload/v1615641749/codestus/kbb1wo4uw7jqzeyhq8nw.jpg","slug":"cac-ky-thuat-viet-code-javascript-ma-ban-khong-the-khong-biet","description":"Từ lúc ra đời đến nay, javascript đã thay đổi rất nhiều, tính đến nay. Chúng ta có hàng chục các viết cho 1 điều kiện trong javascript, rất nhiều các để giải quyết 1 vấn đề, có thể rất dài dòng hoặc phức tạp. Đến nay, các cách giải quyết dang được các nhà sáng lập JavaScript đơn giản hoá nó bằng các cách thức đơn giản hơn qua từng phiên bản.","content":"Từ lúc ra đời đến nay, javascript đã thay đổi rất nhiều, tính đến nay. Chúng ta có hàng chục các viết cho 1 điều kiện trong javascript, rất nhiều các để giải quyết 1 vấn đề, có thể rất dài dòng hoặc phức tạp. Đến nay, các cách giải quyết dang được các nhà sáng lập JavaScript đơn giản hoá nó bằng các cách thức đơn giản hơn qua từng phiên bản.\n\nTrong bài viết này, chúng ta sẽ đào bới một số kỹ thuật giúp ta thuận lợi hơn trong quá trình code, ngoài ra cũng tăng khả năng teamwork cho bạn và partner.\n\n## Sử dụng phương thức includes\nMột câu điều kiện dài dòng thế này, có thể dài hơn sức tưởng tượng của bạn\n```js\nif (value === 'a' || value === 'b' || value === 'c') { ... }\n```\n\nChúng ta có thể thay thế chúng, bằng phương thức `includes` của [Array.prototype.method](https://developer.mozilla.org/vi/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)\n```js\nif([\"a\", \"b\", \"c\"].includes(value)) {}\n```\nSạch sẽ hơn và giúp bạn tránh quá nhiều điều kiện `if`\n\n## Chuyển đổi Boolean bằng Double !\nCó thể sử dụng 2 lần dấu `!` để chuyển đổi một biến bất kỳ sang dạng `boolean` để xử lý điều kiện của bạn\n\n```js\nconst isLoading = null;\nconst inMyMind = \"\u003c\u003e\u003c\u003e\u003c\u003e\"\n\nconsole.log(!!isLoading) // false\nconsole.log(!!inMyMind) // true\n```\n\n## Optional Chaining\nTrong javascript, bạn thường sẽ cần truy xuất các `key` trong `object`. Một số trường hợp chúng ta sẽ truy xuất các `key` không hề tồn tại, như thế javascript sẽ báo lỗi. Chúng ta có thể khắc phục nó bằng cách sử dụng `optional chaining`. \n\n`optional chaining` sẽ truy xuất và trả về giá trị trước đó nếu phía sau `?.` không tồn tại.\n\n```js\nconst obj = {\n\tname: \"a\",\n\tage: 20,\n}\n\nconsole.log(\"data\", obj.name, obj.age); // Hiển thị dữ liệu\nconsole.log(\"Not optional chaining\", obj.haha);\nconsole.log(\"Optional Chaining\", obj?.nooooo);\n\n```\n\n## Không sử dụng else khi dùng if\nThông thường, chúng ta sẽ hay viết điều kiện nếu a thì b thế này\n\n```js\nif (...) {\n  return a\n} else {\n  return a\n}\n```\n\nChúng ta có thể thay thế bằng cách này, chuyển các điều kiện không tồn tại vào `if` và trả về điều kiện thoả như bên dưới\n\n```js\nif(!isOpen) {\n\treturn;\n}\n\nreturn \"OK\";\n```\n\n## Thay thế .forEach bằng .map, .filter, .reduce, .. etc\nMình cảm thấy rất khó chịu khi sử dụng `forEach` để lọc dữ liệu một mảng hoặc thay đổi cấu trúc của phần tử trong mảng bằng `forEach`, thường sẽ phải tạo một mảng khác để chứa những dữ liệu được thay đổi. Thay vì vậy, mình sử dụng các `Array.method` đã được cung cấp hỗ trợ code tốt hơn và dễ đọc hơn rất nhiều.\n\n### .forEach vs .filter\nThử nghiệm: Lọc mảng chỉ lấy các số khác 0\n```js\nconst numbers = [1,2,23,4,5,0,1,0,2]\n// .forEach\n let filtered = [];\n\nnumbers.forEach(numb =\u003e {\n\tif(numb !== 0) {\n\t\tfiltered.push(numb);\n\t}\n})\n\nconsole.log(filtered);\n\n// .filter\nlet usingFilter = numbers.filter(numb =\u003e numb !== 0);\n```\nCùng một kết quả nhưng `.filter` nhỉnh hơn về thời gian viết code và dễ hiểu hơn.\n\n### Map\nTương tự, mình muốn nhân các số trong mảng với 2 với `.map` chỉ cần\n```js\nlet results = [1,2,3,4].map(el =\u003e el * 2);\n\nconsole.log(results);\n```\n\n### Reduce\nHay là thử tính tổng một mảng nhé.\n\n```js\nlet results = [1,2,3,4,5].reduce((total, numb) =\u003e total + numb, 0);\n\nconsole.log(results);\n```\n\nNhìn thôi chúng ta cũng đủ thấy sự khác biệt nếu sử dụng `forEach` và các thương thức tương tự này.\n\n- Tham khảo thêm về các phương thức của mảng trong javascript: [Tại mozilla](https://developer.mozilla.org/vi/docs/Web/JavaScript/Reference/Global_Objects/Array)\n\n## Kết luận\nHãy thử nghiệm và áp dụng vào dự án của bạn thử nhé. Sẽ tốt hơn nhiều lần so với cách viết code phức tạp mà chúng ta nghĩ ra đó.","userId":2,"status":1,"created_at":"2021-03-12T17:56:08.000000Z","updated_at":"2022-03-31T08:00:02.000000Z","publish_at":"2021-03-13 00:56:08"},{"postId":43,"title":"CSRF Protection và những điều cần phải biết","views":1361,"thumbnail":"","slug":"csrf-protection-va-nhung-djieu-can-phai-biet","description":"Mọi người có tự hỏi vì sao một số email khi nhận được lại nằm trong thư mục spam?. Thành thật mà nói thì hãy thận trọng khi truy cập một trang web tràn ngập quảng cáo và chiêu dụ đá số đã được đính kèm trong mail đó.","content":"Mọi người có tự hỏi vì sao một số email khi nhận được lại nằm trong thư mục spam?. Thành thật mà nói thì hãy thận trọng khi truy cập một trang web tràn ngập quảng cáo và chiêu dụ đá số đã được đính kèm trong mail đó.\n\nKẻ tấn công đằng sau đó có thể lừa bạn làm điều gì đó độc hại, chẳng hạn như xóa tài khoản của bạn trên một trang web, chuyển tiền bất hợp pháp, v.v. Đây là tất cả các kết quả có thể xảy ra từ một cuộc tấn công CSRF.\n\nCác cuộc tấn công CSRF ngày nay không còn phổ biến bởi lẽ các công nghệ đã kiến trúc việc ngăn chặn nó từ bên trong lõi trước khi đến tay các lập trình viên xây dựng ứng dụng. Việc chúng ta hiểu cách chúng hoạt động là rất quan trọng nếu muốn xây dựng các dịch vụ và ứng dụng web an toàn.\n\n## A Bird's-Eye View of CSRF\n\nCSRF là viết tắt cho **cross-site request forgery**\n\n## Cross-Site Request\n\n**Cross-site request** đơn giản là gửi một yêu cầu từ trang B đến trang A. Nghe có vẻ khá là bình thường :)). Việc này chỉ bình thường khi chúng ta cho phép yêu cầu đó.\n\nCho ví dụ: Trong trường hợp mình muốn xoá tài khoản Firebase khỏi tài khoản Google của mình. Khá là bình thường đúng không?. Tuy nhiên, nếu mình cũng làm tương tự thế nhưng bằng cách sử dụng một tài khoản khác khong thuộc sở hữu Firebase, để xoá tài khoản Firebase khỏi tài khoản Google, thì đây rất có thể đã bị xâm hại bằng cách trên.\n\nĐến đây có thể bạn bắt đầu đặt câu hỏi tại sao rồi đúng không? Tại sao mình muốn xóa tài khoản Firebase của mình bằng một số tài khoản, trang web ngẫu nhiên khác không có mối liên quan với nó?\n\nCó thể có một vài trường hợp sử dụng phục vụ cho mục đích này. Ví dụ, mình có thể cho phép tài khoản GG Cloud được quyền xoá tài khoản Firebase của mình. Tương tự có thể cho phép tài khoản Facebook xoá tài khoản Instargram?. Tuy nhiên là, nếu bạn truy cập một trang web ngẫu nhiên nào đó khiến tất cả tài khoản Instagram hiện tại bị xoá sạch? bạn biết lý do rồi đấy\n\n## Forgery (Hay còn gọi là giả mạo)\n\nThuật ngữ \"giả mạo\" ở đây có nghĩa là thực hiện yêu cầu bất hợp pháp một hành động mà bạn không được phép làm thực hiện.\n\nVậy, CSRF hay còn gọi là **Cross-site Request Forgery** có nghĩa là mô tả một yêu cầu gửi đến phía máy chủ và nó không xác định được yêu cầu giả mạo được gửi đến. Vậ làm thế nào tin tặc có thể làm điều đó?\n\n## Cuộc tấn công CSRF\n\nNào nào, bây giờ hãy xem cách kẻ tấn công có thể thực hiện một cuộc tấn công CSRF vào ứng dụng của bạn.\n\n### Ứng dụng cho cuộc thí nghiệm\n\nGiả sử ứng dụng của bạn có một trang chủ đơn giản và một trang profile. Trang chủ ứng dụng của bạn hiển thị cho bất kỳ ai trên web. Để ngắn gọn, ứng dụng sau đây hiển thị một trang đơn giản liệt kê một vài người dùng.\n\n![Demo app](https://images.ctfassets.net/nx13ojx82pll/2Epkfe1EfdyR3f4thXhOfz/8643a12931da0400210d0b54471fcb2e/react-csrf-protection-guide-examples-and-how-to-enable-it-picture-2.png?w=1802\u0026h=790\u0026q=80\u0026fm=webp)\n\nTuy nhiên, để truy cập trang hồ sơ, người dùng phải được xác thực trên ứng dụng. Bên trong trang **profile**. sẽ cho một thực hiện một hành động là xoá tài khoản đang được xem.\n\n![Demo app delete account](https://images.ctfassets.net/nx13ojx82pll/6AxQqCNkfD02WospUr7FOY/c860cbb012ebe8939957f04d466ad873/react-csrf-protection-guide-examples-and-how-to-enable-it-picture-3.png?w=1796\u0026h=694\u0026q=80\u0026fm=webp)\n\n### Luồng xác thực cho ứng dụng thử nghiệm\n\nGiả sử người dùng của bạn cố gắng đăng nhập vào ứng dụng của bạn bằng biểu mẫu đăng nhập. Người dùng điền vào biểu mẫu này để xác thực thông tin đăng nhập của họ từ máy chủ. Giống như hầu hết các luồng xác thực thông thường, máy chủ sẽ gửi một cookie được sử dụng để quản lý phiên của người dùng. Cookie này được lưu trữ trong trình duyệt và được gửi lại với mọi yêu cầu xác thực tính xác thực của người dùng.\n\n### Lỗ hổng bảo mật\n\nGiả sử một người dùng muốn xóa tài khoản của họ trên trang web của bạn. Để làm điều này. Người dùng phải ấn vào nút **Xoá**. Tuy nhiên, chỉ người đã được nhập vài tài khoản mới được thực hiện điều này.\n\nKhi người dùng ấn **Xoá**, phía máy khác sẽ gửi một yêu cầu đến máy chủ của bạn. Nó sẽ xử lý yêu cầu này và tính toán để xoá dữ liệu trên database. Yêu cầu xoá đó có dạng như thế này.\n\n![Demo app delete request](https://images.ctfassets.net/nx13ojx82pll/3Da3UL7JcGJWuNGk3jRtxN/c3f2c1bbf6cceaf65c5db68150de6a31/react-csrf-protection-guide-examples-and-how-to-enable-it-picture-4.png?w=1800\u0026h=574\u0026q=80\u0026fm=webp)\n\nĐể xác thực được yêu cầu **Xoá** này, trình duyệt của người dùng sẽ lưu trữ phiên token của máy chủ trong cookie. Tuy nhiên, điều này để lại lỗ hổng CSRF trong ứng dụng của bạn. Tin tặc có thể gửi yêu cầu **xoá** này với cookie đang được lưu trữ trên trình duyệt. Tất cả những gì chúng cần bạn làm là mở một liên kết có biểu mẫu ẩn kích hoạt yêu cầu xóa này trong nền ứng dụng. Hãy xem cách này hoạt động như thế nào.\n \n### Tấn công\n\nTrong ví dụ này, điểm kích hoạt cuộc tấn công là mở một **Đường dẫn**. Kẻ tấn công tạo ra một URL trỏ đến một ứng dụng web khác. Sau đó, kẻ tấn công sử dụng kỹ thuật xã hội để mở URL đó trong trình duyệt của người dùng.\n\nNgay sau khi ứng dụng tải, nó có quyền truy cập vào cookie phiên được lưu trữ trong trình duyệt của bạn. !!!! Cuộc tấn công có thể được kích hoạt ẩn, trong nền, trong khi tải liên kết độc hại mà bận vừa ấn vào đấy. Và hậu quả thế nào thì bạn cũng biết rồi đấy. Đối tượng có thể sử dụng phiên token đã được lưu trữ ở trình duyệt để thực hiện bất cứ yêu cầu nào mà nó có thể.\n\n## CSRF Protection: Myth Busters\n\nĐể hiểu cách bạn có thể bảo vệ ứng dụng của mình khỏi cuộc tấn công **CSRF**, trước tiên bạn phải hiểu các giải pháp là không chắn chắn hoàn toàn. Những giải pháp này có vẻ dễ dàng, nhưng kẻ tấn công có thể dễ dàng qua mặt chúng. Và ứng dụng của bạn vẫn có thể dễ bị tấn công CSRF. Chúng ta hãy xem nhanh những điều này:\n\n### Sử dụng Web Storage thay vì Cookies\n\nBạn nghĩ răng có thể sử dụng các loại lưu trữ storage trên trình duyệt sẽ giải quyết được vấn đề này (localStorage, sessionStorage). Nhưng, kẻ tấn công lại có thể truy cập nó bất cứ lúc nào chỉ cần sử dụng\n\n```js\nconst token = localStorage.getItem(\"token\");\n```\n\n### Sử dụng POST request\n\nNếu bạn cấu trúc lại các điểm gọi đến máy chủ của mình với yêu cầu là phương thức **POST**. Bạn vẫn không hoàn toàn an toàn trước cuộc **tấn công CSRF**. Trong phần trước, mình đã minh họa một ví dụ về yêu cầu xóa để xóa tài khoản của người dùng. Đây cũng có thể là một yêu cầu **GET**, Tuy nhiên thì đổi sang **POST** cũng chẳng khác gì!\n\n## CSRF Protection: The Reliable Solution\n\n### Sử dụng CORS\n\nSử dụng **CORS** nói đơn giản là giao thức quyết định có cho phép một request lạ nào đó ở phía máy khách có thể được thực hiện hay không được vào nguồn gốc của nó (Domain).\n\n```js\n// Dễ bị tấn công\napp.get('/delete',(req,res)=\u003e{\n res.set('Access-Control-Allow-Origin', '*');\n ...\n\n})\n\n// Chỉ cho phép các yêu cầu từ csrfprotection-client.com\napp.get('/delete',(req,res)=\u003e{ \n   res.set('Access-Control-Allow-Origin', 'csrfprotection-client.com'); \n   ... \n})\n```\n\n### Sử dụng CSRF Tokens\n\nCSRF Token, còn được gọi là Anti CSRF Token. Trước khi người dùng thực hiện gửi yêu cầu đến phía máy chủ, sẽ gửi yêu cầu lấy mã CSRF token để đính kèm cho yêu cầu sắp được gửi. Và tinh tế ở đây là token này chỉ tồn tại sau phiên đó, nó sẽ không được tái sử dụng cho các phiên yêu cầu khác. Tức là nó chỉ tồn tại trong một lần gửi yêu cầu.\n\nTuy nhiên, bạn cần đảm bảo rằng bạn không có bất kỳ lỗ hổng XSS nào trong ứng dụng của mình có thể làm rò rỉ các mã thông báo này cho kẻ tấn công. React đã bảo vệ bạn khỏi các cuộc tấn công XSS, nhưng đây là một hướng dẫn thú vị có thể giúp ích cho bạn nếu bạn muốn biết thêm.\n\nTham khảo [chi tiết](https://www.stackhawk.com/blog/react-csrf-protection-guide-examples-and-how-to-enable-it/)","userId":2,"status":1,"created_at":"2021-09-14T17:48:53.000000Z","updated_at":"2022-03-31T08:20:01.000000Z","publish_at":"2021-09-16 00:41:00"}]},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"huong-dan-su-dung-usecallback-trong-react"},"buildId":"8s9ir4i9lyTEt-H4jTUBS","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>